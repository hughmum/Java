**程序**

为完成特定任务，用某种语言编写的一组指令的集合

**进程**

运行的程序，操作系统为其分配内存空间。

进程是程序的一次执行过程，有自身的产生存在消亡。

# **线程**

**线程是由进程创建的，一个进程可以拥有多个线程.**

迅雷同时下载多个文件，就是多个线程

# 并发并行

![image-20220919153657385](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191536699.png)

```java
public class Main {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        //获取当前电脑的cpu数量
        System.out.println(runtime.availableProcessors());
    }
}
```

# 线程使用

![image-20220919154638955](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191546003.png)

### 继承Thread类

```java
/**
 * 继承Thread类创建线程
 */
public class Main {
    public static void main(String[] args) {
        //创建Cat对象，当作线程使用
        Cat cat = new Cat();
        cat.start();//启动线程
    }
}

//继承饿了Thread，该类就可以当作线程使用
class Cat extends Thread {
    @Override
    public void run() {//重写run，写自己的业务逻辑,而run方法，是实现了runable接口的方法
        int times = 0;
        while (true) {
            //每隔一秒输出
            System.out.println("ling" + "线程名称" + Thread.currentThread().getName());
            //休眠一秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            times++;
            if (times == 10) break;
        }

    }
}
```

# 多线程机制

当启动程序的时候，**相当于启动了一个进程**，过后马上进入到主方法，进入到主方法就相当于这个进行**开启了一个主线程**main，当启动线程的start方法后，又相当于**启动了一个子线程**

![image-20220919161015374](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191610463.png)

![image-20220919161146494](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191611580.png)

当主线程输出60次的时候，主线程挂掉了，但是子线程还在，等子线程执行完后，进程才会挂掉，jconcole也就没有响应了。

**说明主线程结束了，进程不一定结束**

```java
/**
 * 继承Thread类创建线程
 */
public class Main {
    public static void main(String[] args) throws InterruptedException {
        //创建Cat对象，当作线程使用
        Cat cat = new Cat();
        cat.start();//启动线程,和主线程不会阻塞，交替进行
        for (int i = 0; i <= 90; i++) {
            System.out.println("主线程" + i +" " + Thread.currentThread());
            Thread.sleep(1000);
        }
    }
}

//继承饿了Thread，该类就可以当作线程使用
class Cat extends Thread {
    @Override
    public void run() {//重写run，写自己的业务逻辑,而run方法，是实现了runable接口的方法
        int times = 0;
        while (true) {
            //每隔一秒输出
            System.out.println("ling" + "线程名称" + Thread.currentThread().getName());
            //休眠一秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            times++;
            if (times == 90) break;
        }

    }
}
```

# 为什么是start

如果用cat调用这个run方法，相当于是由主线程直接调用run方法，就是一个普通方法，执行后才向下执行。

**源码**

```java
public synchronized void start() {
    start0();
}

private native void start0();//是本地方法，底层是JVM c++，真正实现多线程的方法
```

start方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态，具体什么时候执行，取决于CPU，统一调度。

![image-20220919163358470](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191633564.png)



# 线程使用（实现Runable接口）

**java是单继承的，在某些情况下已经继承了某个父类，**这时用Thread类方法来创建线程不可能

**底层使用了代理模式**

```java
public class Thread02 {
    public static void main(String[] args) {
        Dog dog = new Dog();//不能直接start
        Thread thread = new Thread(dog);
        thread.start();

    }
}
class Dog implements Runnable {
    int count = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("xiaogou");
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**模拟代理**

```java
public class Thread02 {
    public static void main(String[] args) {
//        Dog dog = new Dog();//不能直接start
//        Thread thread = new Thread(dog);
//        thread.start();
        Tiger tiger = new Tiger();
        ThreadProxy threadProxy = new ThreadProxy(tiger);//因为tiger实现了Runable接口，所以tiger才能传进去
        threadProxy.start();

    }
}
class Animal {}
class Tiger extends Animal implements Runnable {

    @Override
    public void run() {
        System.out.println("叫");
    }
}
//模拟了一个既简单的Thread
class ThreadProxy implements Runnable {

    private Runnable target = null;//属性，类型是Runable
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

    public ThreadProxy(Runnable target) {
        this.target = target;
    }
    public void start() {
        start0();
    }
    public void start0() {
        run();
    }
}
class Dog implements Runnable {
    int count = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("xiaogou");
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![image-20220919214828169](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209192148529.png)

```java
public class Thread03 {
    public static void main(String[] args) {
        T1 t1 = new T1();
        T2 t2 = new T2();
        Thread thread1 = new Thread(t1);
        Thread thread2 = new Thread(t2);
        thread1.start();
        thread2.start();

    }
}

class T1 implements Runnable {

    int count = 0;

    @Override
    public void run() {
        while (true) {
            System.out.println("hello");
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

class T2 implements Runnable {

    int count = 0;

    @Override
    public void run() {
        while (true) {
            System.out.println("world");
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

# 区别

**实现接口方法更适合多个线程共享一个资源的情况**



# 多线程买票

超卖现象

![image-20220919220144418](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209192201562.png)

```java
/**
 * 多线程，模拟三个窗口同时售票
 */
public class Main {
    public static void main(String[] args) throws InterruptedException {
//        SellTicket01 sellTicket01 = new SellTicket01();
//        SellTicket01 sellTicket02 = new SellTicket01();
//        SellTicket01 sellTicket03 = new SellTicket01();
//        //这里出现超卖现象
//        sellTicket01.start();
//        sellTicket02.start();
//        sellTicket03.start();

        SellTicket02 sellTicket02 = new SellTicket02();
        //同样会超卖
        new Thread(sellTicket02).start();
        new Thread(sellTicket02).start();
        new Thread(sellTicket02).start();
    }
}
//继承Thread
class  SellTicket01 extends  Thread {
    private static int ticketNum = 100;//让多个线程共享ticketNum
    @Override
    public void run() {
        while (true) {
            if (ticketNum <= 0) {
                System.out.println("售票结束");
                break;
            }
            //休眠50ms
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("窗口" + Thread.currentThread().getName() + "售出一张票" + "剩余票数" + --ticketNum);
        }
    }
}

class  SellTicket02 implements   Runnable {
    private  int ticketNum = 100;//让多个线程共享ticketNum
    @Override
    public void run() {
        while (true) {
            if (ticketNum <= 0) {
                System.out.println("售票结束");
                break;
            }
            //休眠50ms
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("窗口" + Thread.currentThread().getName() + "售出一张票" + "剩余票数" + --ticketNum);
        }
    }
}
```

**案例**

启动线程t，并在main线程中停止线程t

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        t.start();
        //希望主线程控制t的退出，就是修改loop
        //通知方法
        Thread.sleep(10000);
        t.setLoop(false);
    }
}
class T extends Thread {
    //设置一个控制变量
    private boolean loop = true;
    @Override
    public void run() {
        while (loop) {
            System.out.println("111");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

# 线程中断

### 线程常用方法

![image-20220920131834591](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209201318815.png)

interrupt 中断，并没有真正的结束线程，所以一般用于中断正在休眠线程。

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        t.setName("ling");
        t.setPriority(Thread.MIN_PRIORITY);
        t.start();

        //让主线程打印5秒后5个hi就中断子线程的休眠
        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000);
            System.out.println(i);
        }
        System.out.println("t线程的优先级" + t.getPriority());
        t.interrupt();//这里就相当于提前结束休眠
    }
}
class T extends Thread {
    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "---" + i);
            }
            try {
                System.out.println("休眠二十秒");
                Thread.sleep(20000);
            } catch (InterruptedException e) {//捕获到一个中断异常
                System.out.println(Thread.currentThread().getName() + "被interrupt 中断了");
            }
        }
    }
}
```

# 线程插队

调用的是对方的join方法

![image-20220920141231968](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209201412584.png)

### 线程常用方法二

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        t.start();
        for (int i = 1; i < 20; i++) {
            Thread.sleep(1000);
            System.out.println("主线程" + i);
            if (i == 5) {
                System.out.println("主线程让子线程先吃完");
//                t.join();
                t.yield();//礼让
                System.out.println("老大吃完了，主线程再吃");
            }
        }
    }
}
class T extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + "---" + i + "子线程在运行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {//捕获到一个中断异常
                System.out.println(Thread.currentThread().getName() + "被interrupt 中断了");
            }
        }
    }
}
```

### 作业

![image-20220920141945725](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209201419926.png)

```java
public class Test {
    public static void main(String[] args) throws InterruptedException {
        Thread t3 = new Thread(new T());
        for (int i = 1; i <= 10; i++) {
            System.out.println("hi" + i);
            if (i == 5) {
                t3.start();
                t3.join();
            }
        }
    }
}
class T implements  Runnable {
    private int count = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("hello" + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (count == 10) {
                break;
            }
        }
    }
}
```

# 守护线程

1. 用户线程，工作线程，当线程的任务执行完成或通知方式结束
2. 守护线程，一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。
3. 常见的守护线程，垃圾回收机制

当主线程结束了，及时t1是一个无限循环的，它也能够自动退出就是一个守护线程

```java
public class Test {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        Thread thread = new Thread(t);
        //如果我们希望当main线程结束后，子线程自动结束
        //将子线程设为守护线程
        thread.setDaemon(true);
        thread.start();
        for (int i = 1; i <= 10; i++) {
            System.out.println("working");
            Thread.sleep(1000);
        }
    }
}
class T implements  Runnable {
    private int count = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("hello" + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

# 线程的七种状态

- - [`NEW`](../../java/lang/Thread.State.html#NEW)  
		尚未启动的线程处于此状态。 
	- [`RUNNABLE`](../../java/lang/Thread.State.html#RUNNABLE)  
		在Java虚拟机中执行的线程处于此状态。 
	- [`BLOCKED`](../../java/lang/Thread.State.html#BLOCKED)  
		被阻塞等待监视器锁定的线程处于此状态。 
	- [`WAITING`](../../java/lang/Thread.State.html#WAITING)  
		正在等待另一个线程执行特定动作的线程处于此状态。 
	- [`TIMED_WAITING`](../../java/lang/Thread.State.html#TIMED_WAITING)  
		正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 
	- [`TERMINATED`](../../java/lang/Thread.State.html#TERMINATED)  
		已退出的线程处于此状态。 

	一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。

新建 就绪 运行 等待 终止

![image-20220920150103016](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209201501282.png)

```java
public class ThreadState {
    public static void main(String[] args) throws InterruptedException {
        TT t = new TT();
        System.out.println(t.getName() + "状态" + t.getState());
        t.start();

        //当前状态不等于终止态就打印出来
        while (Thread.State.TERMINATED != t.getState()) {
            System.out.println(t.getName() + "状态" + t.getState());
            Thread.sleep(500);
        }

        System.out.println(t.getName() + "状态" + t.getState());
     }
}

class TT extends Thread {
    @Override
    public void run() {
        while (true) {
            for (int i = 1; i <= 10; i++) {
                System.out.println("hello" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            break;
        }
    }
}
```

> Runable代表可运行状态，但是它是否真的运行要却决于内核的调度器来决定，就绪，运行，Ready Running，如果线程被挂起，进入ready状态，yield进入ready状态，如果是join就是进入wting或者timewaiting

# 线程同步机制 （Synchronized）

1. 在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多又也给线程访问，以保证数据的完整性。
2. 理解为 线程同步 即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作。直到该线程完成操作，其他线程才能对该内存地址进行操作。

### 同步具体方法

只有在一个线程进入到这个对象的时候，只有他持有这个对象锁，他才可以操作，操作完过后，再把这个锁放回去，另外一个线程进来，再拿到这个对象锁，才能够进去。
