# 项目开发流程

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209280927033.png" alt="image-20220928092736372" style="zoom: 33%;" />

# 需求

1. 用户登录
2. 拉取在线用户
3. 无异常退出
4. 私聊
5. 群聊
6. 发文件
7. 服务器推送新闻

# 分析

每个通讯都需要通过socket来管理，而每创建一个socket就要创建一个线程对象，由于要群发消息，客户端就要拿到所有的线程，所以线程要装在一个管理线程的集合里面。

一个客户端也有可能有多个线程跟服务端进行链接，分别传送消息，文件，视频……

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209280948557.png" alt="image-20220928094820050" style="zoom:33%;" />

# 用户登录功能

### 创建共有的类，序列化

Message.class

```java
/**
 * 通讯消息
 */
public class Message implements Serializable {
    private static final long serialVersionUID = 1L;
    private String sender;
    private String getter;
    private String content;
    private String sendTime;
    private String mesType;//消息类型

    public String getSender() {
        return sender;
    }

    public void setSender(String sender) {
        this.sender = sender;
    }

    public String getGetter() {
        return getter;
    }

    public void setGetter(String getter) {
        this.getter = getter;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getSendTime() {
        return sendTime;
    }

    public void setSendTime(String sendTime) {
        this.sendTime = sendTime;
    }

    public String getMesType() {
        return mesType;
    }

    public void setMesType(String mesType) {
        this.mesType = mesType;
    }
}
```

MessageType 接口

```java
public interface MessageType {
    String MESSAGE_LOGIN_SUCCEED = "1";
    String MESSAGE_LOGIN_FAIL = "2";
}
```

User.class

```java
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private String userId;
    private String password;

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```



### **界面以及登录输入验证**

界面

```java
public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";

    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (false) {
                        System.out.println("=========欢迎"+ userId +"=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    break;
                                case "3" :
                                    System.out.println("私发消息");
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}
```

创建线程类，把socket传到里面去，然后把线程放到集合

**每个socket维护的是他对映客户端的通讯**

### 服务端

```java
/**
 * 这是服务端，监听9999，等待客户端连接，保持通信
 */
public class QQServer {
    private ServerSocket ss = null;
    //创建一个集合，用户信息的数据库
    //这里使用处理并发的集合
    private static ConcurrentHashMap<String, User> validUsers = new ConcurrentHashMap<>();

    static {//在静态代码块初始化 validUsers
        validUsers.put("111", new User("111","111"));
        validUsers.put("222", new User("222","222"));
        validUsers.put("333", new User("333","333"));
    }
    //验证用户是否有效的方法
    private boolean checkUser(String userId, String password) {
        User user  = validUsers.get(userId);
        if (user == null) {
            return false;
        }
        if (!user.getPassword().equals(password)) {
            return false;
        }
        return true;
    }

    public QQServer() {
        try {
            System.out.println("服务端在9999端口监听");
            ss = new ServerSocket(9999);//端口可以写在配置文件中

            while (true) { //当和某个客户端连接后，会继续监听，因此while
                Socket socket = ss.accept();
                //得到socket关联的输出流
                ObjectOutputStream oos =
                        new ObjectOutputStream(socket.getOutputStream());
                //得到socket关联的对象输入流
                ObjectInputStream ois =
                        new ObjectInputStream(socket.getInputStream());
                User user = (User) ois.readObject();//读取客户端发送的user对象
                //创建一个message对象，准备回复客户端
                Message message = new Message();
                //验证用户
                if (checkUser(user.getUserId(), user.getPassword())) {
                    //登录验证通过
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    //将message对象回复客户端
                    oos.writeObject(message);
                    //创建一个线程，和客户端保持通信，该线程需要持有socket对象
                    ServerConnectClientThread serverConnectClientThread =
                            new ServerConnectClientThread(socket, user.getUserId());
                    //启动线程
                    serverConnectClientThread.start();
                    //把该线程对象，放入到一个集合里，管理
                    ManageClientThreads.addClientThread(user.getUserId(), serverConnectClientThread);
                } else {
                    System.out.println("验证失败，登录失败");
                    //失败
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    //登录失败了，还是要关闭socket的
                    socket.close();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //如果服务器退出了while 说明服务器不在监听，因此关闭ServerSocket
            try {
                ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();
                //后面会使用message
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
/**
 * 该类用于管理和客户端通信的线程
 */
public class ManageClientThreads {
    private static HashMap<String, ServerConnectClientThread> hashMap = new HashMap<>();
    //将线程对象添加到hm集合中
    public static void addClientThread(String userId, ServerConnectClientThread serverConnectClientThread) {
        hashMap.put(userId, serverConnectClientThread);
    }
    //根绝userid取出线程
    public static ServerConnectClientThread getServerConnectClientThread(String userId) {
        return hashMap.get(userId);
    }
}
```

```java
/**
 * 该类创建qqserver对象，启动后台服务
 */
public class QQFrame {
    public static void main(String[] args) {

        new QQServer();
    }
}
```



### 客户端

```java
public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册

    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.chekcUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    break;
                                case "3" :
                                    System.out.println("私发消息");
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}
```

```java
/**
 * 完成用户登录验证和注册等功能
 */
public class UserClientService {
    private User user = new User();
    //因为socket在其他地方也有可能使用，因此作出属性
    private Socket socket;
    //根据userId和pwd到服务器验证该用户是否合法
    public boolean chekcUser(String userId, String  pwd) {
        boolean b = false;
        user.setUserId(userId);
        user.setPassword(pwd);
        //连接服务器，发送user对象
        try {
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
            //得到对象liu
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);//发送user对象

            //读取从服务端回复的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if (ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)) {//登录成功

                //创建一个和服务器端保持通信的线程 -》 创建一个类，ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread =
                        new ClientConnectServerThread(socket);
                //启动客户端的线程
                clientConnectServerThread.start();
                //这里为了后面客户端的扩展，我们将线程放入到集合管理
                ManageClientConnectServerThread.addClientConnectServerThread(userId,clientConnectServerThread);
                b = true;
            } else {
                //如果登录失败，我们就不能启动和服务器通讯的线程，关闭socket
                socket.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
}
```

线程类

```java
public class ClientConnectServerThread extends Thread{
    //该线程持有Socket
    private Socket socket;

    public ClientConnectServerThread(Socket socket) {
        this.socket = socket;
    }

    //
    @Override
    public void run() {
        //因为线程需要在后台和服务器通讯，因此我们while循环
        while (true) {
            try {
                System.out.println("客户但线程，等待读取从服务端发送的消息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();//如果服务器没有发送message线程会阻塞在这里

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    public Socket getSocket() {
        return socket;
    }
}
```

管理

```java
/**
 * 管理客户端连接到服务器端线程的一个类
 */
public class ManageClientConnectServerThread {
    //把多个线程放入到一个HashMap集合，key就是用户id， value就是线程
    private static HashMap<String, ClientConnectServerThread> hm = new HashMap<>();

    //将某个线程加入集合
    public static void addClientConnectServerThread(String userId, ClientConnectServerThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }

    //通过userid 可以得到对应线程
    public static ClientConnectServerThread getClientConnectServerThread(String userId) {
        return hm.get(userId);
    }
}

```

工具类

```java
package com.mu.qqclient.utils;


/**
	工具类的作用:
	处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入。
*/

import java.util.*;
/**

	
*/
public class Utility {
	//静态属性。。。
    private static Scanner scanner = new Scanner(System.in);

    
    /**
     * 功能：读取键盘输入的一个菜单选项，值：1——5的范围
     * @return 1——5
     */
	public static char readMenuSelection() {
        char c;
        for (; ; ) {
            String str = readKeyBoard(1, false);//包含一个字符的字符串
            c = str.charAt(0);//将字符串转换成字符char类型
            if (c != '1' && c != '2' && 
                c != '3' && c != '4' && c != '5') {
                System.out.print("选择错误，请重新输入：");
            } else break;
        }
        return c;
    }

	/**
	 * 功能：读取键盘输入的一个字符
	 * @return 一个字符
	 */
    public static char readChar() {
        String str = readKeyBoard(1, false);//就是一个字符
        return str.charAt(0);
    }
    /**
     * 功能：读取键盘输入的一个字符，如果直接按回车，则返回指定的默认值；否则返回输入的那个字符
     * @param defaultValue 指定的默认值
     * @return 默认值或输入的字符
     */
    
    public static char readChar(char defaultValue) {
        String str = readKeyBoard(1, true);//要么是空字符串，要么是一个字符
        return (str.length() == 0) ? defaultValue : str.charAt(0);
    }
	
    /**
     * 功能：读取键盘输入的整型，长度小于2位
     * @return 整数
     */
    public static int readInt() {
        int n;
        for (; ; ) {
            String str = readKeyBoard(10, false);//一个整数，长度<=10位
            try {
                n = Integer.parseInt(str);//将字符串转换成整数
                break;
            } catch (NumberFormatException e) {
                System.out.print("数字输入错误，请重新输入：");
            }
        }
        return n;
    }
    /**
     * 功能：读取键盘输入的 整数或默认值，如果直接回车，则返回默认值，否则返回输入的整数
     * @param defaultValue 指定的默认值
     * @return 整数或默认值
     */
    public static int readInt(int defaultValue) {
        int n;
        for (; ; ) {
            String str = readKeyBoard(10, true);
            if (str.equals("")) {
                return defaultValue;
            }
			
			//异常处理...
            try {
                n = Integer.parseInt(str);
                break;
            } catch (NumberFormatException e) {
                System.out.print("数字输入错误，请重新输入：");
            }
        }
        return n;
    }

    /**
     * 功能：读取键盘输入的指定长度的字符串
     * @param limit 限制的长度
     * @return 指定长度的字符串
     */

    public static String readString(int limit) {
        return readKeyBoard(limit, false);
    }

    /**
     * 功能：读取键盘输入的指定长度的字符串或默认值，如果直接回车，返回默认值，否则返回字符串
     * @param limit 限制的长度
     * @param defaultValue 指定的默认值
     * @return 指定长度的字符串
     */
	
    public static String readString(int limit, String defaultValue) {
        String str = readKeyBoard(limit, true);
        return str.equals("")? defaultValue : str;
    }


	/**
	 * 功能：读取键盘输入的确认选项，Y或N
	 * 将小的功能，封装到一个方法中.
	 * @return Y或N
	 */
    public static char readConfirmSelection() {
        System.out.println("请输入你的选择(Y/N): 请小心选择");
        char c;
        for (; ; ) {//无限循环
        	//在这里，将接受到字符，转成了大写字母
        	//y => Y n=>N
            String str = readKeyBoard(1, false).toUpperCase();
            c = str.charAt(0);
            if (c == 'Y' || c == 'N') {
                break;
            } else {
                System.out.print("选择错误，请重新输入：");
            }
        }
        return c;
    }

    /**
     * 功能： 读取一个字符串
     * @param limit 读取的长度
     * @param blankReturn 如果为true ,表示 可以读空字符串。 
     * 					  如果为false表示 不能读空字符串。
     * 			
	 *	如果输入为空，或者输入大于limit的长度，就会提示重新输入。
     * @return
     */
    private static String readKeyBoard(int limit, boolean blankReturn) {
        
		//定义了字符串
		String line = "";

		//scanner.hasNextLine() 判断有没有下一行
        while (scanner.hasNextLine()) {
            line = scanner.nextLine();//读取这一行
           
			//如果line.length=0, 即用户没有输入任何内容，直接回车
			if (line.length() == 0) {
                if (blankReturn) return line;//如果blankReturn=true,可以返回空串
                else continue; //如果blankReturn=false,不接受空串，必须输入内容
            }

			//如果用户输入的内容大于了 limit，就提示重写输入  
			//如果用户如的内容 >0 <= limit ,我就接受
            if (line.length() < 1 || line.length() > limit) {
                System.out.print("输入长度（不能大于" + limit + "）错误，请重新输入：");
                continue;
            }
            break;
        }

        return line;
    }
}
```





# 拉取在线用户列表

### **客户端**

qqview

```java
package com.mu.qqclient.view;

import com.mu.qqclient.service.UserClientService;
import com.mu.qqclient.utils.Utility;

public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册

    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.checkUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    //写一个方法来获取在线用户列表
                                    userClientService.onlineFriendList();
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    break;
                                case "3" :
                                    System.out.println("私发消息");
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}

```



userclientService

```java
package com.mu.qqclient.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;
import com.mu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;

/**
 * 完成用户登录验证和注册等功能
 */
public class UserClientService {
    private User user = new User();
    //因为socket在其他地方也有可能使用，因此作出属性
    private Socket socket;
    //根据userId和pwd到服务器验证该用户是否合法
    public boolean checkUser(String userId, String  pwd) {
        boolean b = false;
        user.setUserId(userId);
        user.setPassword(pwd);
        //连接服务器，发送user对象
        try {
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
            //得到对象liu
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);//发送user对象

            //读取从服务端回复的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if (ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)) {//登录成功

                //创建一个和服务器端保持通信的线程 -》 创建一个类，ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread =
                        new ClientConnectServerThread(socket);
                //启动客户端的线程
                clientConnectServerThread.start();
                //这里为了后面客户端的扩展，我们将线程放入到集合管理
                ManageClientConnectServerThread.addClientConnectServerThread(userId,clientConnectServerThread);
                b = true;
            } else {
                //如果登录失败，我们就不能启动和服务器通讯的线程，关闭socket
                socket.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
    //向服务器端请求在线用户列表
    public void onlineFriendList() {
        //发送一个message，类型为
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_GET_ONLIN_EFRIEND);
        message.setSender(user.getUserId());
        //发送给服务器
        //应该得到当前客户对映的线程的socket对应的ObjectOutputStream对象
        try {
            ObjectOutputStream oos = new ObjectOutputStream
                    (ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
            oos.writeObject(message);//发送一个message对象，向服务端要求在线用户列表
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

### 服务端

qqserver

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;
import com.mu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 这是服务端，监听9999，等待客户端连接，保持通信
 */
public class QQServer {
    private ServerSocket ss = null;
    //创建一个集合，用户信息的数据库
    //这里使用处理并发的集合
    private static ConcurrentHashMap<String, User> validUsers = new ConcurrentHashMap<>();

    static {//在静态代码块初始化 validUsers
        validUsers.put("111", new User("111","111"));
        validUsers.put("222", new User("222","222"));
        validUsers.put("333", new User("333","333"));
    }
    //验证用户是否有效的方法
    private boolean checkUser(String userId, String password) {
        User user  = validUsers.get(userId);
        if (user == null) {
            return false;
        }
        if (!user.getPassword().equals(password)) {
            return false;
        }
        return true;
    }

    public QQServer() {
        try {
            System.out.println("服务端在9999端口监听");
            ss = new ServerSocket(9999);//端口可以写在配置文件中

            while (true) { //当和某个客户端连接后，会继续监听，因此while
                Socket socket = ss.accept();
                //得到socket关联的输出流
                ObjectOutputStream oos =
                        new ObjectOutputStream(socket.getOutputStream());
                //得到socket关联的对象输入流
                ObjectInputStream ois =
                        new ObjectInputStream(socket.getInputStream());
                User user = (User) ois.readObject();//读取客户端发送的user对象
                //创建一个message对象，准备回复客户端
                Message message = new Message();
                //验证用户
                if (checkUser(user.getUserId(), user.getPassword())) {
                    //登录验证通过
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    //将message对象回复客户端
                    oos.writeObject(message);
                    //创建一个线程，和客户端保持通信，该线程需要持有socket对象
                    ServerConnectClientThread serverConnectClientThread =
                            new ServerConnectClientThread(socket, user.getUserId());
                    //启动线程
                    serverConnectClientThread.start();
                    //把该线程对象，放入到一个集合里，管理
                    ManageClientThreads.addClientThread(user.getUserId(), serverConnectClientThread);
                } else {
                    System.out.println("验证失败，登录失败");
                    //失败
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    //登录失败了，还是要关闭socket的
                    socket.close();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //如果服务器退出了while 说明服务器不在监听，因此关闭ServerSocket
            try {
                ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

serverconnectclient

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();

                //后面会使用message
                //开始处理客户端返回来的mseeage信息
                if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLIN_EFRIEND)) {
                    System.out.println(message.getSender() + "要获取在线用户列表");
                    String onlineUsers = ManageClientThreads.getOnlineUser();
                    //返回给客户端message
                    Message message2 = new Message();
                    message2.setGetter(message.getSender());
                    message2.setContent(onlineUsers);
                    message2.setMesType(MessageType.MESSAGE_RET_ONLIN_EFRIEND);
                    //返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message2);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

前两个流程，服务端创建一个端口不断监听，获取客户端的输入流，如果获取到一个对象，开始验证，如果通过，就发送回给一个通过的消息，然后创建一个线程，将此时的socket对象保存到里面，保持两者的通信，并把线程放在容器里面，然后线程不断run，等待着客户端的进一步操作，当接受到各类消息的时候，判断消息类型，操作，然后返回给客户端内容

客户端，先在输入用户名和密码后传到服务端判断，如果返回的消息成功，创建一个线程 socket保持通信，run线程，并把线程放入集合中，二级菜单，然后选择操作，发送给服务端消息，线程是不断run的，一旦读取到对映的消息就输出

那如何保证服务端的线程和客户端的线程一一对应呢？这样理解，因为服务端不断while 一旦接收到一个客户端的用户，就停止阻塞进行下面的操作，这样两者自然连接，完后，继续while，再次收到消息就是另一个socket

# 退出异常

主线程创建的一个线程一直处于run，循环执行，虽然主线程退出了，但是进程还没有退出

解决，主线程中调动方法，给服务器端发送退出系统的消息，调用System.exit退出，正常退出

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209290957560.png" alt="image-20220929095711983" style="zoom:33%;" />

### 客户端

```java
package com.mu.qqclient.view;

import com.mu.qqclient.service.UserClientService;
import com.mu.qqclient.utils.Utility;

public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册

    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.checkUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    //写一个方法来获取在线用户列表
                                    userClientService.onlineFriendList();
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    break;
                                case "3" :
                                    System.out.println("私发消息");
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    //调用方法
                                    userClientService.logout();
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}

```

```java
package com.mu.qqclient.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;
import com.mu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;

/**
 * 完成用户登录验证和注册等功能
 */
public class UserClientService {
    private User user = new User();
    //因为socket在其他地方也有可能使用，因此作出属性
    private Socket socket;
    //根据userId和pwd到服务器验证该用户是否合法
    public boolean checkUser(String userId, String  pwd) {
        boolean b = false;
        user.setUserId(userId);
        user.setPassword(pwd);
        //连接服务器，发送user对象
        try {
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
            //得到对象liu
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);//发送user对象

            //读取从服务端回复的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if (ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)) {//登录成功

                //创建一个和服务器端保持通信的线程 -》 创建一个类，ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread =
                        new ClientConnectServerThread(socket);
                //启动客户端的线程
                clientConnectServerThread.start();
                //这里为了后面客户端的扩展，我们将线程放入到集合管理
                ManageClientConnectServerThread.addClientConnectServerThread(userId,clientConnectServerThread);
                b = true;
            } else {
                //如果登录失败，我们就不能启动和服务器通讯的线程，关闭socket
                socket.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
    //向服务器端请求在线用户列表
    public void onlineFriendList() {
        //发送一个message，类型为
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_GET_ONLIN_EFRIEND);
        message.setSender(user.getUserId());
        //发送给服务器
        //应该得到当前客户对映的线程的socket对应的ObjectOutputStream对象
        try {
            ObjectOutputStream oos = new ObjectOutputStream
                    (ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
            oos.writeObject(message);//发送一个message对象，向服务端要求在线用户列表
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    //编写方法，退出客户端，并给服务端发送一个退出系统的message对象
    public void logout() {
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
        message.setSender(user.getUserId());

        //发送message
        try {
            //ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            //推荐以下面这种方式获取
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
            oos.writeObject(message);
            System.out.println(user.getUserId() + " 退出系统 ");
            System.exit(0);//结束进程
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

```

### 服务端

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;
import com.mu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 这是服务端，监听9999，等待客户端连接，保持通信
 */
public class QQServer {
    private ServerSocket ss = null;
    //创建一个集合，用户信息的数据库
    //这里使用处理并发的集合
    private static ConcurrentHashMap<String, User> validUsers = new ConcurrentHashMap<>();

    static {//在静态代码块初始化 validUsers
        validUsers.put("111", new User("111","111"));
        validUsers.put("222", new User("222","222"));
        validUsers.put("333", new User("333","333"));
    }
    //验证用户是否有效的方法
    private boolean checkUser(String userId, String password) {
        User user  = validUsers.get(userId);
        if (user == null) {
            return false;
        }
        if (!user.getPassword().equals(password)) {
            return false;
        }
        return true;
    }

    public QQServer() {
        try {
            System.out.println("服务端在9999端口监听");
            ss = new ServerSocket(9999);//端口可以写在配置文件中

            while (true) { //当和某个客户端连接后，会继续监听，因此while
                Socket socket = ss.accept();
                //得到socket关联的输出流
                ObjectOutputStream oos =
                        new ObjectOutputStream(socket.getOutputStream());
                //得到socket关联的对象输入流
                ObjectInputStream ois =
                        new ObjectInputStream(socket.getInputStream());
                User user = (User) ois.readObject();//读取客户端发送的user对象
                //创建一个message对象，准备回复客户端
                Message message = new Message();
                //验证用户
                if (checkUser(user.getUserId(), user.getPassword())) {
                    //登录验证通过
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    //将message对象回复客户端
                    oos.writeObject(message);
                    //创建一个线程，和客户端保持通信，该线程需要持有socket对象
                    ServerConnectClientThread serverConnectClientThread =
                            new ServerConnectClientThread(socket, user.getUserId());
                    //启动线程
                    serverConnectClientThread.start();
                    //把该线程对象，放入到一个集合里，管理
                    ManageClientThreads.addClientThread(user.getUserId(), serverConnectClientThread);
                } else {
                    System.out.println("验证失败，登录失败");
                    //失败
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    //登录失败了，还是要关闭socket的
                    socket.close();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //如果服务器退出了while 说明服务器不在监听，因此关闭ServerSocket
            try {
                ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

```

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();

                //后面会使用message
                //开始处理客户端返回来的mseeage信息
                if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLIN_EFRIEND)) {
                    System.out.println(message.getSender() + "要获取在线用户列表");
                    String onlineUsers = ManageClientThreads.getOnlineUser();
                    //返回给客户端message
                    Message message2 = new Message();
                    message2.setGetter(message.getSender());
                    message2.setContent(onlineUsers);
                    message2.setMesType(MessageType.MESSAGE_RET_ONLIN_EFRIEND);
                    //返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message2);

                } else if (message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
                    //客户端要退出
                    System.out.println(message.getSender() + "退出");
                    //将这个客户端对映的线程，从集合里面移除
                    ManageClientThreads.removeServerConnectCilentThread(userId);
                    socket.close();//关闭的是这个线程所持有的socket对象，为什么直接用socket，因为这本身就是一个线程对象，不断的run，
                    break;//
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

```java
/**
 * 该类用于管理和客户端通信的线程
 */
public class ManageClientThreads {
    private static HashMap<String, ServerConnectClientThread> hashMap = new HashMap<>();
    //将线程对象添加到hm集合中
    public static void addClientThread(String userId, ServerConnectClientThread serverConnectClientThread) {
        hashMap.put(userId, serverConnectClientThread);
    }
    //将线程对象移除
    public static void removeServerConnectCilentThread(String userId) {
        hashMap.remove(userId);
    }
    //根绝userid取出线程
    public static ServerConnectClientThread getServerConnectClientThread(String userId) {
        return hashMap.get(userId);
    }

    //返回所有在线用户的方法
    public static String getOnlineUser() {
        //遍历集合，去key就可以
        Iterator<String> iterator = hashMap.keySet().iterator();
        String onlineUserList = "";
        while (iterator.hasNext()) {
            onlineUserList += iterator.next().toString() + " ";
        }
        return onlineUserList;
    }
}

```

# 私聊

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209291652982.png" alt="image-20220929165201407" style="zoom: 33%;" />



### 客户端

```java
package com.mu.qqclient.view;

import com.mu.qqclient.service.MessageCilentService;
import com.mu.qqclient.service.UserClientService;
import com.mu.qqclient.utils.Utility;

public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册
    private MessageCilentService messageCilentService = new MessageCilentService();
    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.checkUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    //写一个方法来获取在线用户列表
                                    userClientService.onlineFriendList();
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    break;
                                case "3" :
                                    System.out.println("请输入想要聊天的人");
                                    String getterId = Utility.readString(50);
                                    System.out.println("请输入想说的话");
                                    String content = Utility.readString(100);
                                    messageCilentService.sendMessageToOne(content, userId, getterId);
                                    //方法，把消息发送给服务端
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    //调用方法
                                    userClientService.logout();
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}

```

```java
/**
 * 该类提供和服务端消息的相关方法
 */
public class MessageCilentService {
    /**
     *
     * @param content 内容
     * @param senderId 发送用户id
     * @param getterId 接收用户id
     */
    public void sendMessageToOne(String content, String senderId, String getterId) {
        //构建message
        Message message = new Message();
        message.setSendTime(new Date().toString());
        message.setMesType(MessageType.MESSAGE_COMN_MES);//普通聊天消息类型
        message.setSender(senderId);
        message.setGetter(getterId);
        message.setContent(content);
        System.out.println(senderId + "对 " + getterId + "说 " + content);
        //发送给服务端
        try {
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

```java
package com.mu.qqclient.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;
import com.mu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;

/**
 * 完成用户登录验证和注册等功能
 */
public class UserClientService {
    private User user = new User();
    //因为socket在其他地方也有可能使用，因此作出属性
    private Socket socket;
    //根据userId和pwd到服务器验证该用户是否合法
    public boolean checkUser(String userId, String  pwd) {
        boolean b = false;
        user.setUserId(userId);
        user.setPassword(pwd);
        //连接服务器，发送user对象
        try {
            Socket socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
            //得到对象liu
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);//发送user对象

            //读取从服务端回复的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if (ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)) {//登录成功

                //创建一个和服务器端保持通信的线程 -》 创建一个类，ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread =
                        new ClientConnectServerThread(socket);
                //启动客户端的线程
                clientConnectServerThread.start();
                //这里为了后面客户端的扩展，我们将线程放入到集合管理
                ManageClientConnectServerThread.addClientConnectServerThread(userId,clientConnectServerThread);
                b = true;
            } else {
                //如果登录失败，我们就不能启动和服务器通讯的线程，关闭socket
                socket.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
    //向服务器端请求在线用户列表
    public void onlineFriendList() {
        //发送一个message，类型为
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_GET_ONLIN_EFRIEND);
        message.setSender(user.getUserId());
        //发送给服务器
        //应该得到当前客户对映的线程的socket对应的ObjectOutputStream对象
        try {
            ObjectOutputStream oos = new ObjectOutputStream
                    (ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
            oos.writeObject(message);//发送一个message对象，向服务端要求在线用户列表
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    //编写方法，退出客户端，并给服务端发送一个退出系统的message对象
    public void logout() {
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
        message.setSender(user.getUserId());

        //发送message
        try {
            //ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            //推荐以下面这种方式获取
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
            oos.writeObject(message);
            System.out.println(user.getUserId() + " 退出系统 ");
            System.exit(0);//结束进程
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

```

### 服务端

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    public Socket getSocket() {
        return socket;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();

                //后面会使用message
                //开始处理客户端返回来的mseeage信息
                if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLIN_EFRIEND)) {
                    System.out.println(message.getSender() + "要获取在线用户列表");
                    String onlineUsers = ManageClientThreads.getOnlineUser();
                    //返回给客户端message
                    Message message2 = new Message();
                    message2.setGetter(message.getSender());
                    message2.setContent(onlineUsers);
                    message2.setMesType(MessageType.MESSAGE_RET_ONLIN_EFRIEND);
                    //返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message2);

                } else if (message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
                    //客户端要退出
                    System.out.println(message.getSender() + "退出");
                    //将这个客户端对映的线程，从集合里面移除
                    ManageClientThreads.removeServerConnectCilentThread(userId);
                    socket.close();//关闭的是这个线程所持有的socket对象，为什么直接用socket，因为这本身就是一个线程对象，不断的run，
                    break;//
                } else if (message.getMesType().equals(MessageType.MESSAGE_COMN_MES)) {
                      //根据message获取到getterid 然后再得到getterid客户端对应再服务端的那个线程，然后得到那个线程的socket以及输入流然后发送即可
                    ServerConnectClientThread serverConnectClientThread =
                            ManageClientThreads.getServerConnectClientThread(message.getGetter());
                    //获取输出流，发送
                    ObjectOutputStream oos =
                            new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
                    oos.writeObject(message);//注意一下，如果用户不在线，可以保存到数据库，做成一个离线的消息


                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

# 群发消息

### 客户端

```java
package com.mu.qqclient.view;

import com.mu.qqclient.service.MessageCilentService;
import com.mu.qqclient.service.UserClientService;
import com.mu.qqclient.utils.Utility;

public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册
    private MessageCilentService messageCilentService = new MessageCilentService();
    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.checkUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    //写一个方法来获取在线用户列表
                                    userClientService.onlineFriendList();
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    String s = Utility.readString(100);
                                    //调用一个方法，封装成message对象，发送给服务端
                                    messageCilentService.sendMessageToAll(s, userId);
                                    break;
                                case "3" :
                                    System.out.println("请输入想要聊天的人");
                                    String getterId = Utility.readString(50);
                                    System.out.println("请输入想说的话");
                                    String content = Utility.readString(100);
                                    messageCilentService.sendMessageToOne(content, userId, getterId);
                                    //方法，把消息发送给服务端
                                    break;
                                case "4" :
                                    System.out.println("发送文件");
                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    //调用方法
                                    userClientService.logout();
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}
```

```java
package com.mu.qqclient.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Date;

/**
 * 该类提供和服务端消息的相关方法
 */
public class MessageCilentService {
    /**
     *
     * @param content
     * @param senderId
     */
    public void sendMessageToAll(String content, String senderId) {
        //构建message
        Message message = new Message();
        message.setSendTime(new Date().toString());
        message.setMesType(MessageType.MESSAGE_TO_ALL_MES);//普通聊天消息类型
        message.setSender(senderId);
        message.setContent(content);
        System.out.println(senderId +  "对大家说 " + content);
        //发送给服务端
        try {
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     *
     * @param content 内容
     * @param senderId 发送用户id
     * @param getterId 接收用户id
     */
    public void sendMessageToOne(String content, String senderId, String getterId) {
        //构建message
        Message message = new Message();
        message.setSendTime(new Date().toString());
        message.setMesType(MessageType.MESSAGE_COMN_MES);//普通聊天消息类型
        message.setSender(senderId);
        message.setGetter(getterId);
        message.setContent(content);
        System.out.println(senderId + "对 " + getterId + "说 " + content);
        //发送给服务端
        try {
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

### 服务端

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.HashMap;
import java.util.Iterator;

/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    public Socket getSocket() {
        return socket;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();

                //后面会使用message
                //开始处理客户端返回来的mseeage信息
                if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLIN_EFRIEND)) {
                    System.out.println(message.getSender() + "要获取在线用户列表");
                    String onlineUsers = ManageClientThreads.getOnlineUser();
                    //返回给客户端message
                    Message message2 = new Message();
                    message2.setGetter(message.getSender());
                    message2.setContent(onlineUsers);
                    message2.setMesType(MessageType.MESSAGE_RET_ONLIN_EFRIEND);
                    //返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message2);

                } else if (message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
                    //客户端要退出
                    System.out.println(message.getSender() + "退出");
                    //将这个客户端对映的线程，从集合里面移除
                    ManageClientThreads.removeServerConnectCilentThread(userId);
                    socket.close();//关闭的是这个线程所持有的socket对象，为什么直接用socket，因为这本身就是一个线程对象，不断的run，
                    break;//
                } else if (message.getMesType().equals(MessageType.MESSAGE_COMN_MES)) {
                      //根据message获取到getterid 然后再得到getterid客户端对应再服务端的那个线程，然后得到那个线程的socket以及输入流然后发送即可
                    ServerConnectClientThread serverConnectClientThread =
                            ManageClientThreads.getServerConnectClientThread(message.getGetter());
                    //获取输出流，发送
                    ObjectOutputStream oos =
                            new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
                    oos.writeObject(message);//注意一下，如果用户不在线，可以保存到数据库，做成一个离线的消息
                } else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {

                    //遍历线程集合 把所有线程的socket得到，然后把message进行转发即可
                    HashMap<String, ServerConnectClientThread> hashMap = ManageClientThreads.getHashMap();

                    Iterator<String> iterator = hashMap.keySet().iterator();
                    while (iterator.hasNext()) {

                        //取出在线用户id
                        String onLineUserId = iterator.next().toString();

                        //排除群发消息的那个人
                        if (!onLineUserId.equals(message.getSender())) {

                            //进行转发message
                            ObjectOutputStream oos =
                                    new ObjectOutputStream(hashMap.get(onLineUserId).getSocket().getOutputStream());
                            oos.writeObject(message);
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

# 发送文件

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209291842531.png" alt="image-20220929184205085" style="zoom:33%;" />

### 客户端

FileClientService.class

```java
package com.mu.qqclient.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.*;

/**
 * 该类完成文件传输服务
 */
public class FileClientService {
    /**
     *
     * @param src 文件源路径
     * @param dest 文件接收地址
     * @param senderId 发送者
     * @param getterId 接收者
     */
    public void sendFileToOne(String src, String dest, String senderId, String getterId) {
        //读取src文件
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_FILE_MES);
        message.setSender(senderId);
        message.setGetter(getterId);
        message.setSrc(src);
        message.setDest(dest);

        //需要将文件读取
        FileInputStream fileInputStream = null;
        byte[] fileBytes = new byte[(int) new File(src).length()];
        //创建了文件字节数组之后就通过文件字节输入流读取，然后封装到message对象，最后发送即可
        try {
            fileInputStream = new FileInputStream(src);
            fileInputStream.read(fileBytes);//读取文件，然后放入fileBytes里面
            message.setFileBytes(fileBytes);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭字节流
            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        //提示信息
        System.out.println("\n" + senderId + "给" + getterId +"发送文件到对方的" + dest +"目录下" );

        //下面开始真正发送
        try {
            ObjectOutputStream oos =
                    new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

```

```java
package com.mu.qqclient.view;

import com.mu.qqclient.service.FileClientService;
import com.mu.qqclient.service.MessageCilentService;
import com.mu.qqclient.service.UserClientService;
import com.mu.qqclient.utils.Utility;

public class QQView {
    private boolean loop = true;//控制是否显示菜单
    private String key = "";
    private UserClientService userClientService = new UserClientService();//这个对象时用于登录服务/注册
    private MessageCilentService messageCilentService = new MessageCilentService();
    private FileClientService fileClientService = new FileClientService();//该对象用于传输文件
    public static void main(String[] args) {
        new QQView().mainMenu();
    }
    //显示主菜单
    private void mainMenu() {
        while (loop) {
            System.out.println("=========欢迎登录系统==========");
            System.out.println("\t\t 1 登录系统");
            System.out.println("\t\t 9 退出系统");

            key = Utility.readString(1);
            //根据用户不同的输入，处理不同逻辑
            switch (key) {
                case "1":
                    System.out.println("请输入用户号");
                    String userId = Utility.readString(50);
                    System.out.println("请输入密码");
                    String pwd = Utility.readString(50);
                    //需要到服务端验证该用户是否合法
                    if (userClientService.checkUser(userId, pwd)) {
                        System.out.println("=========欢迎"+ userId +"登录成功=========");
                        //进入到二级菜单
                        while (loop) {
                            System.out.println("\n==========二级菜单"+userId+"=======");
                            System.out.println("\t\t 1 显示在线用户列表");
                            System.out.println("\t\t 2 群发消息");
                            System.out.println("\t\t 3 私发消息");
                            System.out.println("\t\t 4 发送文件");
                            System.out.println("\t\t 9 退出系统");
                            System.out.println("请输入你的选择");
                            key = Utility.readString(1);
                            switch (key) {
                                case "1" :
                                    System.out.println("显示在线用户列表");
                                    //写一个方法来获取在线用户列表
                                    userClientService.onlineFriendList();
                                    break;
                                case "2" :
                                    System.out.println("群发消息");
                                    String s = Utility.readString(100);
                                    //调用一个方法，封装成message对象，发送给服务端
                                    messageCilentService.sendMessageToAll(s, userId);
                                    break;
                                case "3" :
                                    System.out.println("请输入想要聊天的人");
                                    String getterId = Utility.readString(50);
                                    System.out.println("请输入想说的话");
                                    String content = Utility.readString(100);
                                    messageCilentService.sendMessageToOne(content, userId, getterId);
                                    //方法，把消息发送给服务端
                                    break;
                                case "4" :
                                    System.out.println("请输入把文件发送给的用户");
                                    getterId = Utility.readString(50);
                                    System.out.println("请输入发送文件的路径");
                                    String src = Utility.readString(100);
                                    System.out.println("输入文件发送到的路径");
                                    String dest = Utility.readString(100);
                                    fileClientService.sendFileToOne(src, dest, userId, getterId);

                                    break;
                                case "9" :
                                    System.out.println("退出系统");
                                    //调用方法
                                    userClientService.logout();
                                    loop = false;
                                    break;
                            }
                        }
                    } else { //登录失败
                        System.out.println("密码错误");
                    }

                    break;
                case "9":
                    System.out.println("退出系统");
                    loop = false;
                    break;
            }
        }
    }
}

```

### 服务端

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.HashMap;
import java.util.Iterator;

/**
 * 该类的一个对象，和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId;//连接到服务器的用户ID
    public ServerConnectClientThread (Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    public Socket getSocket() {
        return socket;
    }

    @Override
    public void run() {//线程处于run状态，可以接发消息
        while (true) {
            try {
                System.out.println("服务端和客户端"+userId+"保持通信，不断读取信息");
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();

                //后面会使用message
                //开始处理客户端返回来的mseeage信息
                if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLIN_EFRIEND)) {
                    System.out.println(message.getSender() + "要获取在线用户列表");
                    String onlineUsers = ManageClientThreads.getOnlineUser();
                    //返回给客户端message
                    Message message2 = new Message();
                    message2.setGetter(message.getSender());
                    message2.setContent(onlineUsers);
                    message2.setMesType(MessageType.MESSAGE_RET_ONLIN_EFRIEND);
                    //返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message2);

                } else if (message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
                    //客户端要退出
                    System.out.println(message.getSender() + "退出");
                    //将这个客户端对映的线程，从集合里面移除
                    ManageClientThreads.removeServerConnectCilentThread(userId);
                    socket.close();//关闭的是这个线程所持有的socket对象，为什么直接用socket，因为这本身就是一个线程对象，不断的run，
                    break;//
                } else if (message.getMesType().equals(MessageType.MESSAGE_COMN_MES)) {
                      //根据message获取到getterid 然后再得到getterid客户端对应再服务端的那个线程，然后得到那个线程的socket以及输入流然后发送即可
                    ServerConnectClientThread serverConnectClientThread =
                            ManageClientThreads.getServerConnectClientThread(message.getGetter());
                    //获取输出流，发送
                    ObjectOutputStream oos =
                            new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
                    oos.writeObject(message);//注意一下，如果用户不在线，可以保存到数据库，做成一个离线的消息
                } else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {

                    //遍历线程集合 把所有线程的socket得到，然后把message进行转发即可
                    HashMap<String, ServerConnectClientThread> hashMap = ManageClientThreads.getHashMap();

                    Iterator<String> iterator = hashMap.keySet().iterator();
                    while (iterator.hasNext()) {

                        //取出在线用户id
                        String onLineUserId = iterator.next().toString();

                        //排除群发消息的那个人
                        if (!onLineUserId.equals(message.getSender())) {

                            //进行转发message
                            ObjectOutputStream oos =
                                    new ObjectOutputStream(hashMap.get(onLineUserId).getSocket().getOutputStream());
                            oos.writeObject(message);
                        }
                    }
                } else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) {
                    //就是直接根据getter获取到对应的线程将message对象转发
                    ObjectOutputStream oos =
                            new ObjectOutputStream(ManageClientThreads.getServerConnectClientThread(message.getGetter()).getSocket().getOutputStream());
                    oos.writeObject(message);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```





# 服务器推送新闻

**本质就是群发消息**

令起一个线程来处理

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209291936579.png" alt="image-20220929193641199" style="zoom:33%;" />

### 服务端

```java
package com.mu.qqserver.service;

import com.mu.qqcommon.Message;
import com.mu.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Scanner;

public class SendNewsToAllService implements Runnable{

    private Scanner scanner = new Scanner(System.in);

    @Override
    public void run() {

        //为了能够推送多次新闻，使用while
        while (true) {
            System.out.println("请输入要发送的消息");
            String news = scanner.nextLine();
            if ("exit".equals(news)) break;
            //构建一个message
            Message message = new Message();
            message.setContent(news);
            message.setMesType(MessageType.MESSAGE_TO_ALL_MES);
            message.setSender("服务器");
            message.setSendTime(new Date().toString());
            System.out.println("服务器对所有人说" + news);

            //遍历所有线程，得到socket并发送
            HashMap<String, ServerConnectClientThread> hashMap = ManageClientThreads.getHashMap();

            Iterator<String> iterator = hashMap.keySet().iterator();
            while (iterator.hasNext()) {
                String id = iterator.next().toString();
                try {
                    ObjectOutputStream oos =
                            new ObjectOutputStream(ManageClientThreads.getServerConnectClientThread(id).getSocket().getOutputStream());
                    oos.writeObject(message);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



