## 内存存在形式

![image-20220628131907434](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628131907434.png)

## 属性

成员变量=属性=field字段

<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628134157844.png" alt="image-20220628134157844" style="zoom:50%;" />

首先加载person类信息，包括属性信息和方法信息，new是在堆里开空间，会返回一个地址，那这个栈就指向一个空间，堆里的那个，

<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628134449923.png" alt="image-20220628134449923" style="zoom: 50%;" />

只会加载一次类信息

1.  先加载 Person 类信息(属性和方法信息, 只会加载一次) 
2. 在堆中分配空间, 进行默认初始化(看规则) 
3. 把地址赋给 p , p 就指向对象 
4.  进行指定初始化， 比如 p.name =”jack” p.age = 1

![image-20220628151539191](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628151539191.png)

## 方法修饰符

引用类型传参<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628153150854.png" alt="image-20220628153150854" style="zoom:50%;" />

如果传递的参数是类的话，同样是引用类型

<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628153442452.png" alt="image-20220628153442452" style="zoom:50%;" />

```java
class Person {
String name;
int age;
}
class B {
public void test200(Person p) {
//p.age = 10000; //修改对象属性
//思考
p = new Person();
p.name = "tom";
p.age = 99;
//思考
//p = null;
}
//B 类中编写一个方法 test100，
//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化
public void test100(int[] arr) {
arr[0] = 200;//修改元素
//遍历数组
System.out.println(" test100 的 arr 数组 ");
for(int i = 0; i < arr.length; i++) {
System.out.print(arr[i] + "\t");
}
System.out.println();
}

```

如果在另一个类中将p置为空，那仅仅是把这个栈中p指向的地址置为空

![image-20220628153855238](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220628153855238.png)

克隆对象

最终指向的是同一个内存池空间，只是将地址在拷贝

![image-20220629143003518](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220629143003518.png)

## 递归

#### 内存![image-20220629144945719](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220629144945719.png)

#### 阶乘过程<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220629145501716.png" alt="image-20220629145501716" style="zoom:33%;" />

#### 递归准则

![image-20220629145602597](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220629145602597.png)

<img src="https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220629145638988.png" style="zoom: 50%;" />

### 迷宫

```java
import java.util.*;
import java.util.concurrent.ForkJoinPool;

public class Main{
    public static void main(String[] args) {
        int[][] map  = {
            {1,1,1,1,1,1,1},
            {1,0,0,0,0,0,1},
            {1,0,0,0,0,0,1},
            {1,1,1,1,0,0,1},
            {1,0,0,0,0,0,1},
            {1,0,0,0,0,0,1},
            {1,0,0,0,0,0,1},
            {1,1,1,1,1,1,1}
        };
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
        AA t1  = new AA();
        t1.findway(map, 1, 1);
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        } 
    }
}
class AA{
    public boolean findway(int[][] map,int i,int j){
        if(map[6][5]==2) return true;
        else{
            if(map[i][j]==0){
                map[i][j] = 2;
                if(findway(map,i+1,j)) return true;
                else if(findway(map, i, j+1)) return true;
                else if(findway(map, i-1, j))return true;
                else if(findway(map, i, j-1)) return true;
                else{
                    map[i][j] = 3;
                    return false;
                }
            }
            else{
                return false;
            }
        }
    }
}
```

### 汉诺塔

```java
import java.util.*;
import java.util.concurrent.ForkJoinPool;

public class Main{
    public static void main(String[] args) {
       Tower tower = new Tower();
       tower.move(2, 'a', 'b', 'c');
    }
}


class Tower {
    public void move(int num,char a,char b,char c){
        if(num==1){
            System.out.println(a+"->"+c);
        }
        else{
            move(num-1,a,c,b);
            System.out.println(a+"->"+c);
            move(num-1,b,a,c);
        }
    }
}
```

### 八皇后

```java
import java.util.*;
import java.util.concurrent.ForkJoinPool;

public class Main{

    public static void main(String[] args) {
    //八皇后问题
    que q = new que();
    q.check(0);
    q.print();
    }
}

class que{
    int max = 8;
    int arr[] = new int[max];
    static int count = 0;
    static int judgecount = 0;

   public void check(int n){
        if(n==max){
           count++;  
            return ;
        }
        else{
            for (int i = 0; i < max; i++) {
                arr[n] = i;//放在第i列
                if(judge(n)){
                    check(n+1);
                }
            }
        }
    }
    public void print(){
     System.out.println(count);
    }
    public boolean judge(int n){
        for(int i=0;i<n;i++){
            if(arr[i] == arr[n]||Math.abs(i-n)==Math.abs(arr[i]-arr[n])){
                    return false;
            }
        }
        return true;
    }
}
```

## 重载

在同一个类里面拥有相同方法名，就是方法的重载，但形参列表不是一样的

![image-20220701091711120](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220701091711120.png)

但是参数名字没有要求，

```java
class methods{
    public void m(int x){

    }
    public void m(int x,int y){
        
    }
}
```

## 可变参数

```java
import java.util.*;
import java.util.concurrent.ForkJoinPool;

public class Main{

    public static void main(String[] args) {
        //计算n个数的和
        int arr[] = {1,3,4};
        HspMethod h = new HspMethod();
        int s=  h.sum(arr);
        System.out.println(s);
    }
}

class HspMethod{
    //int...表示接收的是可变参数，可以接受0-多个，nums可以当作数组
    public int sum(int...nums){
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res+=nums[i];
        }
        return res;
    }
}
```

## 构造器

![image-20220702233220297](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220702233220297.png)

构造方法主要是完成对新对象的初始化

![image-20220702233308153](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220702233308153.png)

```java
public class Main{
    public static void main(String[] args) {
        new Person("pName", 66);
    }
}

class Person{
    String name;
    int age;
    //不能写void
    public Person(String pName,int pAge){
        System.out.println("构造器被调用");
        name = pName;
        age = pAge;
    }
}
```

### 使用细节

![image-20220702233922017](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220702233922017.png)

![image-20220702234508095](https://gitee.com/hughmum/typere-drawing-bed/raw/master/img/image-20220702234508095.png)

```java
class Dog {
//如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
//使用 javap 指令 反编译看看
/*
默认构造器
Dog() {
}
*/
//一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，
//除非显式的定义一下,即: Dog(){} 写 (这点很重要)
//
public Dog(String dName) {
//... }
Dog() { //显式的定义一下 无参构造器
}
}

```

## 对象创建流程

1. 在方法区中，加载person类信息
2. 在堆中分配空间，地址
3. 完成对象初始化，默认初始化，显式初始化，构造器初始化
4. 在对象在堆中的地址，返回给p

## this

