# Java绘图图标体系

![image-20220914171349512](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209141713948.png)

![image-20220914190948820](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209141909278.png)

```java
public class Main extends JFrame{//JFrame对应窗口，是一个画框
    //定义一个面板，是放在画框里的
    public MyPanel mp = null;
    public static void main(String[] args) {
        new Main();
        System.out.println("退出程序");
    }
    public Main() {//构造器
        //初始化面板
        mp = new MyPanel();
        //把面板放入到窗口
        this.add(mp);
        //设置窗口大小
        this.setSize(400, 300);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//当点击x程序就推出
        this.setVisible(true);

    }
}
//定义一个MyPanel, 继承JPanel类，画图形，在面板上
class MyPanel extends JPanel {
    //Graphics画笔
    @Override
    public void paint(Graphics g) {//绘图方法
        super.paint(g);//调用父类方法，完成初始化
        System.out.println("paint调用");
        g.drawOval(10, 10, 100, 100);
        //演示绘制不同的图形.. //画直线 drawLine(int x1,int y1,int x2,int y2)
        //g.drawLine(10, 10, 100, 100);
        //画矩形边框 drawRect(int x, int y, int width, int height)
        //g.drawRect(10, 10, 100, 100);
        //画椭圆边框 drawOval(int x, int y, int width, int height)
        //填充矩形 fillRect(int x, int y, int width, int height)
        //设置画笔的颜色
        // g.setColor(Color.blue);
        // g.fillRect(10, 10, 100, 100);
        //填充椭圆 fillOval(int x, int y, int width, int height)
        // g.setColor(Color.red);
        // g.fillOval(10, 10, 100, 100);
        //画图片 drawImage(Image img, int x, int y, ..)
        //1. 获取图片资源, /bg.png 表示在该项目的根目录去获取 bg.png 图片资源
        // Image image = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource("/bg.png"));
        // g.drawImage(image, 10, 10, 175, 221, this);
        //画字符串 drawString(String str, int x, int y)//写字
        //给画笔设置颜色和字体
        g.setColor(Color.red);
        g.setFont(new Font("隶书", Font.BOLD, 50));
        //这里设置的 100， 100， 是 "北京你好"左下角
        g.drawString("北京你好", 100, 100);
        //设置画笔的字体 setFont(Font font)
        //设置画笔的颜色 setColor(Color c)
    }
}
```

# 绘制坦克游戏区域

tank

```java
package mu.tankgame;

public class Tank {
    private int x;//坦克横坐标
    private  int y;//坦克纵坐标

    public Tank(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }
}

```

自己的坦克

```java
package mu.tankgame;

/**
 * 自己的坦克
 */
public class Hero extends Tank{
    public Hero(int x, int y) {
        super(x, y);
    }
}

```

绘图区域

```java
/**
 * 坦克大战的绘图区域
 */
public class Mypanel extends JPanel {
    //定义我的坦克
    Hero hero = null;
    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
    }
}

```

边框

```java
public class TankGame01 extends JFrame {
    //定义Panel,因为将来的panel是要放在jrame上面去的
    Mypanel mp = null;
    public static void main(String[] args) {
        TankGame01 tankGame01 = new TankGame01();
    }
    public TankGame01() {
        mp = new Mypanel();
        this.add(mp);//把面板，游戏的绘图区域加进去
        this.setSize(1000,750);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
    }
}

```

# 绘制坦克

![image-20220918230229624](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209182302201.png)

```java
/**
 * 坦克大战的绘图区域
 */
public class Mypanel extends JPanel {
    //定义我的坦克
    Hero hero = null;
    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(),hero.getY(),g,0,1);
        drawTank(hero.getX() + 60,hero.getY(),g,0,1);
    }
    //编写方法画出坦克

    /**
     *
     * @param x 坦克左上角x坐标
     * @param y 坐上角y坐标
     * @param g 画笔
     * @param direct 坦克方向
     * @param type 坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x,y,10,60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30,y,10,60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,20,40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10,y + 20,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20,y + 30,x + 20,y);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
}

```



# 小球移动 java的事件控制

```java
package mu.event;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/***
 * 键盘控制上下左右，java的事件控制演示
 */
public class BallMove extends JFrame{
    Mypanel mp = null;

    public static void main(String[] args) {
        BallMove ballMove = new BallMove();
    }
    public BallMove() {
        mp = new Mypanel();
        this.add(mp);
        this.setSize(400,300);
        //JFrame对象可以监听到键盘事件
        this.addKeyListener(mp);//接口的引用可以指向实现了接口的对象
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        this.setVisible(true);

    }
}

/**
 * KeyListener监听器，键盘事件
 */
class Mypanel extends JPanel implements KeyListener {
    //把做上角坐标设置变量
    int x = 10, y = 10;
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillOval(x, y, 20, 20);
    }
    //监听有字符输出时，触发
    @Override
    public void keyTyped(KeyEvent e) {

    }
    //单某个键按下，触发
    @Override
    public void keyPressed(KeyEvent e) {
        //System.out.println((char)e.getKeyCode() + "被按下");
        //根据用户按下的键处理小球的移动
        if (e.getKeyCode() == KeyEvent.VK_DOWN) {
            y++;
        } else if (e.getKeyCode() == KeyEvent.VK_UP) {
            y--;
        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            x--;
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            x++;
        }
        //让面板重绘一下
        this.repaint();
    }
    //某个键松开触发
    @Override
    public void keyReleased(KeyEvent e) {

    }
}
```

# java事件处理机制

采用委派事件模型

![image-20220919121402474](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191214911.png)

**深入理解**

![image-20220919122233769](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191222059.png)

**案例**

```java
/***
 * 键盘控制上下左右，java的事件控制演示
 */
public class BallMove extends JFrame{
    Mypanel mp = null;

    public static void main(String[] args) {
        BallMove ballMove = new BallMove();
    }
    public BallMove() {
        mp = new Mypanel();
        this.add(mp);
        this.setSize(400,300);
        //JFrame对象可以监听到键盘事件
        this.addKeyListener(mp);//接口的引用可以指向实现了接口的对象
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        this.setVisible(true);

    }
}

/**
 * KeyListener监听器，键盘事件
 */
class Mypanel extends JPanel implements KeyListener {
    //把做上角坐标设置变量
    int x = 10, y = 10;
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillOval(x, y, 20, 20);
    }
    //监听有字符输出时，触发
    @Override
    public void keyTyped(KeyEvent e) {

    }
    //单某个键按下，触发
    @Override
    public void keyPressed(KeyEvent e) {
        //System.out.println((char)e.getKeyCode() + "被按下");
        //根据用户按下的键处理小球的移动
        if (e.getKeyCode() == KeyEvent.VK_DOWN) {
            y++;
        } else if (e.getKeyCode() == KeyEvent.VK_UP) {
            y--;
        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            x--;
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            x++;
        }
        //让面板重绘一下
        this.repaint();
    }
    //某个键松开触发
    @Override
    public void keyReleased(KeyEvent e) {

    }
}
```



# 绘制坦克上下左右

```java

    /**
     *
     * @param x 坦克左上角x坐标
     * @param y 坐上角y坐标
     * @param g 画笔
     * @param direct 坦克方向
     * @param type 坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x,y,10,60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30,y,10,60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,20,40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10,y + 20,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20,y + 30,x + 20,y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x,y,60,10, false);//画出坦克左边的轮子
                g.fill3DRect(x,y + 30,60,10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,40,20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20,y + 10,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30,y + 20,x + 60,y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x,y,10,60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30,y,10,60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,20,40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10,y + 20,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20,y + 30,x + 20,y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x,y,60,10, false);//画出坦克左边的轮子
                g.fill3DRect(x,y + 30,60,10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,40,20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20,y + 10,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30,y + 20,x,y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
}
```

# 坦克移动

```JAVA
package mu.tankgame2;

public class Tank {
    private int x;//坦克横坐标
    private  int y;//坦克纵坐标
    private int direct;//坦克方向 0 1 2 3 上左下右
    private int speed = 2;//坦克的速度

    //上右下左移动
    public void moveUp() {
        y -= speed;
    }
    public void moveRight() {
        x += speed;
    }
    public void moveDown() {
        y += speed;
    }
    public void moveLeft() {
        x -= speed;
    }

    public Tank(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getDirect() {
        return direct;
    }

    public void setDirect(int direct) {
        this.direct = direct;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}

```



```java
/**
 * 坦克大战的绘图区域
 */
public class Mypanel extends JPanel implements KeyListener {
    //定义我的坦克
    Hero hero = null;
    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(),hero.getY(),g,hero.getDirect(),0);
        drawTank(hero.getX() + 60,hero.getY(),g,hero.getDirect(),1);
    }
    //编写方法画出坦克

    /**
     *
     * @param x 坦克左上角x坐标
     * @param y 坐上角y坐标
     * @param g 画笔
     * @param direct 坦克方向
     * @param type 坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x,y,10,60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30,y,10,60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,20,40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10,y + 20,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20,y + 30,x + 20,y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x,y,60,10, false);//画出坦克左边的轮子
                g.fill3DRect(x,y + 30,60,10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,40,20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20,y + 10,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30,y + 20,x + 60,y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x,y,10,60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30,y,10,60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,20,40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10,y + 20,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20,y + 30,x + 20,y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x,y,60,10, false);//画出坦克左边的轮子
                g.fill3DRect(x,y + 30,60,10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10,y + 10,40,20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20,y + 10,20,20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30,y + 20,x,y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            hero.moveUp();
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            hero.moveRight();
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            hero.moveDown();
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            hero.moveLeft();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
}
```

### 作业1

![image-20220919144616487](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191446775.png)

![image-20220919150052360](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209191500445.png)

```java
public class EnemyTank extends Tank{
    public EnemyTank(int x, int y) {
        super(x, y);
    }
}





**
 * 坦克大战的绘图区域
 */
public class Mypanel extends JPanel implements KeyListener {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    int enemyTankSize = 2;

    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 0);
            enemyTank.setDirect(2);
            enemyTanks.add(enemyTank);
        }
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            drawTank(enemyTank.getX(), enemyTank.getY(), g,enemyTank.getDirect(),1);
        }
    }
```



0.2**版本**



# 发射子弹

发射子弹，当玩家按下一个j键，就发射一个子弹

思路：

1. 当发射一颗子弹后，就相当于启动了一个线程
2. Hero有子弹的对象，当按下j时，我们就在当前hero类的方法里new出一个子弹对象，然后启动一个发射线程，让子弹不停移动，形成一个设计效果
3. MyPanel需要不停地重绘，才能出现效果
4. 碰到边界，打到别人就销毁，把启动的子弹的线程销毁

```JAVA
public class Shot implements Runnable{
    int x;
    int y;
    int direct = 0;//子弹的方向
    int speed = 2;//速度
    boolean isLive = true;//子弹是否还可以移动，存活

    public Shot(int x, int y, int direct) {
        this.x = x;
        this.y = y;
        this.direct = direct;
    }

    @Override
    public void run() {//射击行为
        while (true) {
            //线程休眠
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //根据方向改变xy坐标
            switch (direct) {
                case 0://上
                    y -= speed;
                    break;
                case 1://右
                    x += speed;
                    break;
                case 2://下
                    y += speed;
                    break;
                case 3://左
                    x -= speed;
                    break;
            }
            //测试，输出
            System.out.println(x+"  " +y);
            //碰到边界
            if (!(x >= 0 && x <= 1000 && y >=0 && y <= 750)) {
                isLive = false;
                break;
            }
        }
    }
}

```

```java
public class Hero extends Tank {
    //定义一个shot对象
    Shot shot = null;//表示一个设计的行为
    public Hero(int x, int y) {
        super(x, y);
    }
    //射击
    public void shotEnemyTank() {
        //创建shot对象，根据当前hero对象的位置，和方向来创建shot
        switch (getDirect()) {//这个是得到坦克自己的方向
            case 0://上
                shot = new Shot(getX() + 20, getY(), 0);
                break;
            case 1://右
                shot = new Shot(getX() + 60, getY() + 20, 1);
                break;
            case 2://下
                shot = new Shot(getX() + 20, getY() + 60, 2);
                break;
            case 3://左
                shot = new Shot(getX(), getY() + 20, 3);
                break;
        }
        //创建好了以后就启动我们的Shot线程
        new Thread(shot).start();
    }
}
```

```java
public class Mypanel extends JPanel implements KeyListener, Runnable {
    
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);

        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
        if (hero.shot != null && hero.shot.isLive == true) {
            System.out.println("子弹被绘制");
            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
        }

        @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            hero.moveUp();
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            hero.moveRight();
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            hero.moveDown();
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            hero.moveLeft();
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
            hero.shotEnemyTank();
        }
        this.repaint();
    }
        
            @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.repaint();
        }
    }
}

```

# 让敌人的坦克也发出子弹，而且可以有多颗子弹

思路

1. 在敌人坦克类，使用Vector保存多个shot

2. 当每创建一个敌人坦克对象，给该敌人坦克对象初始化一个SHOT对象，同时启动shot
3. 在绘制敌人坦克时，需要遍历敌人坦克对象的vector，绘制所有的子弹，当子弹isLive== false时，就从Vector移除

EnemyTank.class

```java
public class EnemyTank extends Tank {
    Vector<Shot> shots = new Vector<>();
    public EnemyTank(int x, int y) {
        super(x, y);
    }
}
```

MyPanel.class

```java
    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 0);
            enemyTank.setDirect(2);
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
    }




    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);

        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
        if (hero.shot != null && hero.shot.isLive == true) {
            System.out.println("子弹被绘制");
            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
        }

        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            drawTank(enemyTank.getX(), enemyTank.getY(), g,enemyTank.getDirect(),1);
            //画出所有子弹
            for ( int j = 0; j < enemyTank.shots.size(); j++) {
                //取出子弹
                Shot shot = enemyTank.shots.get(j);
                //绘制
                if (shot.isLive) {
                    g.draw3DRect(shot.x, shot.y, 2, 2, false);
                } else {
                    //从Vector移除
                    enemyTank.shots.remove(shot);
                }
            }
        }

```



# 敌方坦克消失



子弹消失的情况

Shot.class

```java
//碰到边界,碰到敌人坦克时，也应该结束
            if (!(x >= 0 && x <= 1000 && y >=0 && y <= 750 && isLive)) {
                isLive = false;
                break;
            }
```

碰到敌方坦克的情况

MyPanelc.class

```java
    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public static void hitTank(Shot s, EnemyTank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                }
        }
    }


   @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活

                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(hero.shot, enemyTank);
                }
            }

            this.repaint();
        }
    }

```

# 坦克爆炸

炸弹是属于Panel里的，

Bomb.class

```java
/**
 * 炸弹
 */
public class Bomb {
    int x, y;//坐标
    int life = 9;//炸弹生命周期
    boolean isLive = true;//存活是否

    public Bomb(int x, int y) {
        this.x = x;
        this.y = y;
    }
    //减少生命值
    public void lifeDown() {//配合出现图片的爆炸效果
        if (life > 0) {
            life--;
        } else {
            isLive = false;
        }
    }
}
```

MyPanel类

```java
package mu.tankgame03;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Vector;

/**
 * 坦克大战的绘图区域
 */
//为了监听 键盘事件， 实现KEyListener
//为了让Panel不停的重绘子弹，需要将MyPanel实现Runable接口，当作一个线程使用，不然的话，按下去paint这个方法只会调用一次，
public class Mypanel extends JPanel implements KeyListener, Runnable {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    int enemyTankSize = 4;
    //定义一个vector用于存放炸弹
    //说明当子弹击中坦克时，就加入一个Bomb对象，到bombs
    Vector<Bomb> bombs = new Vector<>();
    //定义三张炸弹图片，用于显示爆炸效果
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;

    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
            enemyTank.setDirect(2);
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
        //初始化图片对象
        image1 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image2 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image3 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);

        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
        if (hero.shot != null && hero.shot.isLive == true) {
            System.out.println("子弹被绘制");
            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
        }

        //如果bombs集合中有对象，就画出炸弹
        for (int i = 0; i < bombs.size(); i++) {
            //取出炸弹
            Bomb bomb = bombs.get(i);
            //根据当前这个bomb对象的life去画出对应的图片
            if (bomb.life > 6) {
                g.drawImage(image1, bomb.x, bomb.y,60,60,this );
            } else if (bomb.life > 3) {
                g.drawImage(image2, bomb.x, bomb.y,60,60,this );
            } else {
                g.drawImage(image3, bomb.x, bomb.y,60,60,this );
            }
            //让这个炸弹的生命值减少
            bomb.lifeDown();
            //如果bomb life为0， 就从bombs 的集合中删除这个bomb
            if (bomb.life == 0) {
                bombs.remove(bomb);
            }
        }
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //判断当前坦克是否存活
            if (enemyTank.isLive) {//只有敌人坦克活着才画
                drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 1);
                //画出所有子弹
                for (int j = 0; j < enemyTank.shots.size(); j++) {
                    //取出子弹
                    Shot shot = enemyTank.shots.get(j);
                    //绘制
                    if (shot.isLive) {
                        g.draw3DRect(shot.x, shot.y, 2, 2, false);
                    } else {
                        //从Vector移除
                        enemyTank.shots.remove(shot);
                    }
                }
            }
        }
    }
    //编写方法画出坦克

    /**
     * @param x      坦克左上角x坐标
     * @param y      坐上角y坐标
     * @param g      画笔
     * @param direct 坦克方向
     * @param type   坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x, y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }

    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public  void hitTank(Shot s, EnemyTank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            hero.moveUp();
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            hero.moveRight();
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            hero.moveDown();
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            hero.moveLeft();
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
            hero.shotEnemyTank();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活

                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(hero.shot, enemyTank);
                }
            }

            this.repaint();
        }
    }
}

```

EnemyTank.class

```java
public class EnemyTank extends Tank {
    Vector<Shot> shots = new Vector<>();
    boolean isLive = true;
    public EnemyTank(int x, int y) {
        super(x, y);
    }
}
```

# 敌人坦克自由移动

当做线程使用，让其实现runable接口，在run方法写上业务代码，在创建敌人坦克时，启动线程

EnemyTank.class

```java
public class EnemyTank extends Tank implements Runnable{
    Vector<Shot> shots = new Vector<>();
    boolean isLive = true;
    public EnemyTank(int x, int y) {
        super(x, y);
    }

    @Override
    public void run() {
        while (true) {
            //根据坦克方向继续移动
            switch (getDirect()) {
                case 0://上
                    //让坦克在这个方向多移动几次
                    for (int i = 0; i < 30; i++) {
                        moveUp();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 1://右
                    for (int i = 0; i < 30; i++) {
                        moveRight();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 2://下
                    for (int i = 0; i < 30; i++) {
                        moveDown();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 3://左
                    for (int i = 0; i < 30; i++) {
                        moveLeft();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
            }
            //移动后休眠
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //随机改变坦克方向
            setDirect((int)(Math.random() * 4));
            //写并发程序，一定要考虑清楚，该线程什么时候结束
            if (!isLive) {
                break;//退出线程
            }
        }
    }
}
```



MyPanel.class

```java
    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
            enemyTank.setDirect(2);
            //启动敌人坦克线程
            new Thread(enemyTank).start();
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
```



# 控制坦克移动范围

![image-20220922142132759](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209221421138.png)

```java

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            if (hero.getY() > 0) {
                hero.moveUp();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            if (hero.getX() + 60 < 1000) {
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            if (hero.getY() + 60 < 750){
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            if (hero.getX() > 0) {
                hero.moveLeft();
            }
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
            hero.shotEnemyTank();
        }
        this.repaint();
    }
```

EnemyTank.class

```java

    @Override
    public void run() {
        while (true) {
            //根据坦克方向继续移动
            switch (getDirect()) {
                case 0://上
                    //让坦克在这个方向多移动几次
                    for (int i = 0; i < 30; i++) {
                        if (getY() > 0) {
                            moveUp();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
```

# 坦克发射多个子弹

![image-20220922151146509](https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209221511694.png)

Hero.class

```java
/**
 * 自己的坦克
 */
public class Hero extends Tank {
    //定义一个shot对象
    Shot shot = null;//表示一个设计的行为
    //可以发射多颗子弹
    Vector<Shot> shots = new Vector<>();
    public Hero(int x, int y) {
        super(x, y);
    }
    //射击
    public void shotEnemyTank() {

        //控制在面板上，最多只有5颗我们的子弹
        if (shots.size() == 5) {
            return ;
        }
        //创建shot对象，根据当前hero对象的位置，和方向来创建shot
        switch (getDirect()) {//这个是得到坦克自己的方向
            case 0://上
                shot = new Shot(getX() + 20, getY(), 0);
                break;
            case 1://右
                shot = new Shot(getX() + 60, getY() + 20, 1);
                break;
            case 2://下
                shot = new Shot(getX() + 20, getY() + 60, 2);
                break;
            case 3://左
                shot = new Shot(getX(), getY() + 20, 3);
                break;
        }
        //把新创建的shot放入到集合当中
        shots.add(shot);
        //创建好了以后就启动我们的Shot线程
        new Thread(shot).start();
    }
}
```

MyPanel.class

```java
/**
 * 坦克大战的绘图区域
 */
//为了监听 键盘事件， 实现KEyListener
//为了让Panel不停的重绘子弹，需要将MyPanel实现Runable接口，当作一个线程使用，不然的话，按下去paint这个方法只会调用一次，
public class Mypanel extends JPanel implements KeyListener, Runnable {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    int enemyTankSize = 4;
    //定义一个vector用于存放炸弹
    //说明当子弹击中坦克时，就加入一个Bomb对象，到bombs
    Vector<Bomb> bombs = new Vector<>();
    //定义三张炸弹图片，用于显示爆炸效果
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;

    public Mypanel() {
        hero = new Hero(100, 100);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
            enemyTank.setDirect(2);
            //启动敌人坦克线程
            new Thread(enemyTank).start();
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
        //初始化图片对象
        image1 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image2 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image3 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);

        //画出坦克-封装方法方法
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);

//        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
//        if (hero.shot != null && hero.shot.isLive == true) {
//            System.out.println("子弹被绘制");
//            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
//        }

        //将hero的子弹集合，遍历取出绘制
        for (int i = 0; i < hero.shots.size(); i++) {
            Shot shot = hero.shots.get(i);
            if (shot != null && shot.isLive == true) {
                g.draw3DRect(shot.x, shot.y, 2, 2, false);
            } else {//如果该shot对象失效，就去除remove
                hero.shots.remove(shot);
            }
        }

        //如果bombs集合中有对象，就画出炸弹
        for (int i = 0; i < bombs.size(); i++) {
            //取出炸弹
            Bomb bomb = bombs.get(i);
            //根据当前这个bomb对象的life去画出对应的图片
            if (bomb.life > 6) {
                g.drawImage(image1, bomb.x, bomb.y,60,60,this );
            } else if (bomb.life > 3) {
                g.drawImage(image2, bomb.x, bomb.y,60,60,this );
            } else {
                g.drawImage(image3, bomb.x, bomb.y,60,60,this );
            }
            //让这个炸弹的生命值减少
            bomb.lifeDown();
            //如果bomb life为0， 就从bombs 的集合中删除这个bomb
            if (bomb.life == 0) {
                bombs.remove(bomb);
            }
        }
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //判断当前坦克是否存活
            if (enemyTank.isLive) {//只有敌人坦克活着才画
                drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 1);
                //画出所有子弹
                for (int j = 0; j < enemyTank.shots.size(); j++) {
                    //取出子弹
                    Shot shot = enemyTank.shots.get(j);
                    //绘制
                    if (shot.isLive) {
                        g.draw3DRect(shot.x, shot.y, 2, 2, false);
                    } else {
                        //从Vector移除
                        enemyTank.shots.remove(shot);
                    }
                }
            }
        }
    }
    //编写方法画出坦克

    /**
     * @param x      坦克左上角x坐标
     * @param y      坐上角y坐标
     * @param g      画笔
     * @param direct 坦克方向
     * @param type   坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x, y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
    //如果我们的坦克可以发射多个子弹，那么在判断我方子弹是否击中坦克的时候，就需要把我们的子弹集合中，所有的子弹，都取出和敌人的所有坦克进行判断
    public void hitEnemyTank() {

        for (int j = 0; j < hero.shots.size(); j++) {
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活
                Shot shot = hero.shots.get(j);
                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(shot, enemyTank);
                }
            }

        }
    }
    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public  void hitTank(Shot s, EnemyTank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            if (hero.getY() > 0) {
                hero.moveUp();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            if (hero.getX() + 60 < 1000) {
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            if (hero.getY() + 60 < 750){
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            if (hero.getX() > 0) {
                hero.moveLeft();
            }
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
//            //判断hero子弹是否存在或者销毁,这是发射一颗子弹的情况
//            if (hero.shot == null || !hero.shot.isLive) {
//                hero.shotEnemyTank();
//            }
            //发射多颗子弹的情况
            hero.shotEnemyTank();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            hitEnemyTank();
            this.repaint();
        }
    }
}
```



# 敌方移动发射

EnemyTank.class

```java
package mu.tankgame03;

import java.util.Vector;

public class EnemyTank extends Tank implements Runnable {
    Vector<Shot> shots = new Vector<>();
    boolean isLive = true;

    public EnemyTank(int x, int y) {
        super(x, y);
    }

    @Override
    public void run() {
        while (true) {
            //控制坦克发出的子弹数量
            if (isLive && shots.size() < 5) {
                Shot shot = null;
                //判断坦克的方向，创建对映的子弹
                switch (getDirect()) {
                    case 0:
                        shot = new Shot(getX() + 20, getY(), 0);
                        break;
                    case 1:
                        shot = new Shot(getX() + 60, getY() + 20, 1);
                        break;
                    case 2:
                        shot = new Shot(getX() + 20, getY() + 60, 2);
                        break;
                    case 3:
                        shot = new Shot(getX(), getY() + 20, 0);
                        break;
                }
                shots.add(shot);
                //启动
                new Thread(shot).start();
            }
            //根据坦克方向继续移动
            switch (getDirect()) {
                case 0://上
                    //让坦克在这个方向多移动几次
                    for (int i = 0; i < 30; i++) {
                        if (getY() > 0) {
                            moveUp();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 1://右
                    for (int i = 0; i < 30; i++) {
                        if (getX() + 60 < 1000) {
                            moveRight();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 2://下
                    for (int i = 0; i < 30; i++) {
                        if (getY() + 60 < 750) {
                            moveDown();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 3://左
                    for (int i = 0; i < 30; i++) {
                        if (getX() > 0) {
                            moveLeft();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
            }
            //移动后休眠
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //随机改变坦克方向
            setDirect((int) (Math.random() * 4));
            //写并发程序，一定要考虑清楚，该线程什么时候结束
            if (!isLive) {
                break;//退出线程
            }
        }
    }
}
```



# 敌方坦克击中我方并爆炸

```java
public class Tank {
    private int x;//坦克横坐标
    private  int y;//坦克纵坐标
    private int direct;//坦克方向 0 1 2 3 上左下右
    private int speed = 2;//坦克的速度
    boolean isLive = true;
```

MyPanel.class

```java
    //编写方法，判断敌人坦克是否击中我方坦克
    public void hitHero() {
        //遍历所有敌人的坦克，然后遍历敌人坦克的所有子弹来判断是否击中我方坦克
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出敌人坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //遍历enemyTank 对象的所有子弹
            for (int j = 0; j < enemyTank.shots.size(); j++) {
                //取出子弹
                Shot shot = enemyTank.shots.get(j);
                //判断shot是否击中我方坦克
                if (hero.isLive && shot.isLive) {
                    hitTank(shot, hero);
                }
            }
        }
    }


    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            hitEnemyTank();
            //继续判断敌人坦克是否击中我
            hitHero();
            this.repaint();
        }
    }
```

# 防止敌人坦克重叠

**8种情况**

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209251649640.png" alt="image-20220925164939893" style="zoom: 33%;" />

EnemyTank
```java
package mu.tankgame03;

import java.util.Vector;

public class EnemyTank extends Tank implements Runnable {
    Vector<Shot> shots = new Vector<>();
    //增加成员，敌人坦克 可以得到所有敌人坦克的Vector
    Vector<EnemyTank> enemyTanks = new Vector<>();

    boolean isLive = true;

    public EnemyTank(int x, int y) {
        super(x, y);
    }
    //这里提供一个方法可以把MyPanel里面的敌人集合设置过来
    public void setEnemyTanks(Vector<EnemyTank> enemyTanks) {
        this.enemyTanks = enemyTanks;
    }
    //编写方法，判断当前这个敌人坦克，是否和enenmyTanks中的其他坦克发生的重叠或者碰撞
    public boolean isTouchEnemyTank() {
        //判断当前敌人坦克，this的方向
        switch (this.getDirect()) {
            case 0://上
                //让当前敌人坦克，和其他敌人坦克比较
                for (int i = 0; i < enemyTanks.size(); i++) {
                    //从vector中取出一辆坦克
                    EnemyTank enemyTank = enemyTanks.get(i);
                    //不和自己比较
                    if (enemyTank != this) {

                        //如果敌人坦克是上下方向
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克的左上角坐标进入其他敌人坦克区域
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +40
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 60) {
                                    return true;
                            }
                            //当前坦克右上角坐标进入敌人坦克区域
                            if (this.getX() + 40>= enemyTank.getX()
                                    && this.getX() + 40 <= enemyTank.getX() +40
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 60) {
                                return true;
                            }
                        }
                        //如果敌人坦克方向是左右
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                             //当前坦克左上角坐标
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +60
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 40) {
                                return true;
                            }
                            //当前坦克右上角坐标
                            if (this.getX() + 40>= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +60
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 40) {
                                return true;
                            }
                        }
                    }
                }
                break;
            case 1://右
                //让当前敌人坦克，和其他敌人坦克比较
                for (int i = 0; i < enemyTanks.size(); i++) {
                    //从vector中取出一辆坦克
                    EnemyTank enemyTank = enemyTanks.get(i);
                    //不和自己比较
                    if (enemyTank != this) {

                        //如果敌人坦克是上下方向
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克的右上角坐标进入其他敌人坦克区域
                            if (this.getX() + 60>= enemyTank.getX()
                                    && this.getX() + 60<= enemyTank.getX() +40
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 60) {
                                return true;
                            }
                            //当前坦克右下角坐标进入敌人坦克区域
                            if (this.getX() + 60>= enemyTank.getX()
                                    && this.getX() + 60 <= enemyTank.getX() +40
                                    && this.getY() + 40>= enemyTank.getY()
                                    && this.getY() + 40<= enemyTank.getY() + 60) {
                                return true;
                            }
                        }
                        //如果敌人坦克方向是左右
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克左上角坐标
                            if (this.getX() + 60>= enemyTank.getX()
                                    && this.getX() + 60<= enemyTank.getX() +60
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 40) {
                                return true;
                            }
                            //当前坦克右上角坐标
                            if (this.getX() + 60>= enemyTank.getX()
                                    && this.getX() + 60<= enemyTank.getX() +60
                                    && this.getY() +40>= enemyTank.getY()
                                    && this.getY() + 40<= enemyTank.getY() + 40) {
                                return true;
                            }
                        }
                    }
                }
                break;
            case 2://下
                //让当前敌人坦克，和其他敌人坦克比较
                for (int i = 0; i < enemyTanks.size(); i++) {
                    //从vector中取出一辆坦克
                    EnemyTank enemyTank = enemyTanks.get(i);
                    //不和自己比较
                    if (enemyTank != this) {

                        //如果敌人坦克是上下方向
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克的左下角坐标进入其他敌人坦克区域
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +40
                                    && this.getY() + 60>= enemyTank.getY()
                                    && this.getY() + 60 <= enemyTank.getY() + 60) {
                                return true;
                            }
                            //当前坦克右下角坐标进入敌人坦克区域
                            if (this.getX() + 40>= enemyTank.getX()
                                    && this.getX() + 40 <= enemyTank.getX() +40
                                    && this.getY() + 60>= enemyTank.getY()
                                    && this.getY() + 60 <= enemyTank.getY() + 60) {
                                return true;
                            }
                        }
                        //如果敌人坦克方向是左右
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克左下角坐标
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +60
                                    && this.getY() + 60>= enemyTank.getY()
                                    && this.getY() + 60<= enemyTank.getY() + 40) {
                                return true;
                            }
                            //当前坦克右下角坐标
                            if (this.getX() + 40>= enemyTank.getX()
                                    && this.getX() + 40<= enemyTank.getX() +60
                                    && this.getY() +60>= enemyTank.getY()
                                    && this.getY() + 60<= enemyTank.getY() + 40) {
                                return true;
                            }
                        }
                    }
                }
                break;
            case 3://左
                //让当前敌人坦克，和其他敌人坦克比较
                for (int i = 0; i < enemyTanks.size(); i++) {
                    //从vector中取出一辆坦克
                    EnemyTank enemyTank = enemyTanks.get(i);
                    //不和自己比较
                    if (enemyTank != this) {

                        //如果敌人坦克是上下方向
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克的左上角坐标进入其他敌人坦克区域
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +40
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 60) {
                                return true;
                            }
                            //当前坦克左下角坐标进入敌人坦克区域
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +40
                                    && this.getY() + 40>= enemyTank.getY()
                                    && this.getY() +40<= enemyTank.getY() + 60) {
                                return true;
                            }
                        }
                        //如果敌人坦克方向是左右
                        if (enemyTank.getDirect() == 0 || enemyTank.getDirect() == 2) {
                            //当前坦克左上角坐标
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +60
                                    && this.getY() >= enemyTank.getY()
                                    && this.getY() <= enemyTank.getY() + 40) {
                                return true;
                            }
                            //当前坦克左下角坐标
                            if (this.getX() >= enemyTank.getX()
                                    && this.getX() <= enemyTank.getX() +60
                                    && this.getY() + 40>= enemyTank.getY()
                                    && this.getY() + 40 <= enemyTank.getY() + 40) {
                                return true;
                            }
                        }
                    }
                }
                break;
        }
        return false;//没有碰撞的情况
    }

    @Override
    public void run() {
        while (true) {
            //控制坦克发出的子弹数量
            if (isLive && shots.size() < 5) {
                Shot shot = null;
                //判断坦克的方向，创建对映的子弹
                switch (getDirect()) {
                    case 0:
                        shot = new Shot(getX() + 20, getY(), 0);
                        break;
                    case 1:
                        shot = new Shot(getX() + 60, getY() + 20, 1);
                        break;
                    case 2:
                        shot = new Shot(getX() + 20, getY() + 60, 2);
                        break;
                    case 3:
                        shot = new Shot(getX(), getY() + 20, 0);
                        break;
                }
                shots.add(shot);
                //启动
                new Thread(shot).start();
            }
            //根据坦克方向继续移动
            switch (getDirect()) {
                case 0://上
                    //让坦克在这个方向多移动几次
                    for (int i = 0; i < 30; i++) {
                        if (getY() > 0 && !isTouchEnemyTank()) {
                            moveUp();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 1://右
                    for (int i = 0; i < 30; i++) {
                        if (getX() + 60 < 1000 && !isTouchEnemyTank()) {
                            moveRight();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 2://下
                    for (int i = 0; i < 30; i++) {
                        if (getY() + 60 < 750 && !isTouchEnemyTank()) {
                            moveDown();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
                case 3://左
                    for (int i = 0; i < 30; i++) {
                        if (getX() > 0 && !isTouchEnemyTank()) {
                            moveLeft();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    break;
            }
            //移动后休眠
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //随机改变坦克方向
            setDirect((int) (Math.random() * 4));
            //写并发程序，一定要考虑清楚，该线程什么时候结束
            if (!isLive) {
                break;//退出线程
            }
        }
    }
}
```

MyPanel

```java
 public Mypanel() {
        hero = new Hero(100, 500);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
            enemyTank.setEnemyTanks(enemyTanks);
            enemyTank.setDirect(2);
            //启动敌人坦克线程
            new Thread(enemyTank).start();
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
```

# 记录玩家成绩

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209252004822.png" alt="image-20220925200439585" style="zoom:33%;" />

定义一个Record类

```java
/**
 * 用来记录相关信息，与文件交互
 */
public class Recorder {
    //定义变量，记录我方击毁敌人坦克数
    private static int allEnemyTank = 0;
    //定义IO对象,准备写到文件中
    private static FileWriter fw = null;
    private static BufferedWriter bw = null;
    private static String recordFile = "src\\record.txt";
    //增加一个方法，当游戏退出时，将allnum保存到recordFile
    public static void keepRecord() {
        try {
            bw = new BufferedWriter(new FileWriter(recordFile));
            bw.write(allEnemyTank + "\r\n");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public static int getAllEnemyTank() {
        return allEnemyTank;
    }

    public static void setAllEnemyTank(int allEnemyTank) {
        Recorder.allEnemyTank = allEnemyTank;
    }
    //当我方坦克击毁一个敌方坦克，就应当allEnemyTank++
    public static void addallEnemyTank() {
        Recorder.allEnemyTank++;
    }

}
```

在hitTank方法中加上判断，绘制那些东西，然后在主类中加上一个监听器

```java
package mu.tankgame03;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Vector;

/**
 * 坦克大战的绘图区域
 */
//为了监听 键盘事件， 实现KEyListener
//为了让Panel不停的重绘子弹，需要将MyPanel实现Runable接口，当作一个线程使用，不然的话，按下去paint这个方法只会调用一次，
public class Mypanel extends JPanel implements KeyListener, Runnable {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    int enemyTankSize = 7;
    //定义一个vector用于存放炸弹
    //说明当子弹击中坦克时，就加入一个Bomb对象，到bombs
    Vector<Bomb> bombs = new Vector<>();
    //定义三张炸弹图片，用于显示爆炸效果
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;

    public Mypanel() {
        hero = new Hero(100, 500);//初始化自己的坦克
        hero.setSpeed(2);
        //初始化敌人坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
            enemyTank.setEnemyTanks(enemyTanks);
            enemyTank.setDirect(2);
            //启动敌人坦克线程
            new Thread(enemyTank).start();
            //给该敌人坦克加入一颗子弹
            Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
            //加入到enemyTank的vector
            enemyTank.shots.add(shot);
            //启动shot对象
            new Thread(shot).start();
            enemyTanks.add(enemyTank);
        }
        //初始化图片对象
        image1 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image2 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image3 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
    }

    //编写方法，显示我方击毁敌方坦克信息
    public void showInfo(Graphics g)  {
        //画出玩家总成绩
        g.setColor(Color.BLACK);
        Font font = new Font("宋体", Font.BOLD, 24);
        g.setFont(font);

        g.drawString("您累积击毁敌方坦克", 1020,30);
        drawTank(1020, 60, g, 0, 1);//画出一个敌方坦克
        g.setColor(Color.BLACK);
        g.drawString(Recorder.getAllEnemyTank() + "", 1080, 100);
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
        showInfo(g);
        //画出坦克-封装方法方法
        if(hero != null && hero.isLive) {
            drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);
        }

//        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
//        if (hero.shot != null && hero.shot.isLive == true) {
//            System.out.println("子弹被绘制");
//            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
//        }

        //将hero的子弹集合，遍历取出绘制
        for (int i = 0; i < hero.shots.size(); i++) {
            Shot shot = hero.shots.get(i);
            if (shot != null && shot.isLive == true) {
                g.draw3DRect(shot.x, shot.y, 2, 2, false);
            } else {//如果该shot对象失效，就去除remove
                hero.shots.remove(shot);
            }
        }

        //如果bombs集合中有对象，就画出炸弹
        for (int i = 0; i < bombs.size(); i++) {
            //取出炸弹
            Bomb bomb = bombs.get(i);
            //根据当前这个bomb对象的life去画出对应的图片
            if (bomb.life > 6) {
                g.drawImage(image1, bomb.x, bomb.y,60,60,this );
            } else if (bomb.life > 3) {
                g.drawImage(image2, bomb.x, bomb.y,60,60,this );
            } else {
                g.drawImage(image3, bomb.x, bomb.y,60,60,this );
            }
            //让这个炸弹的生命值减少
            bomb.lifeDown();
            //如果bomb life为0， 就从bombs 的集合中删除这个bomb
            if (bomb.life == 0) {
                bombs.remove(bomb);
            }
        }
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //判断当前坦克是否存活
            if (enemyTank.isLive) {//只有敌人坦克活着才画
                drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 1);
                //画出所有子弹
                for (int j = 0; j < enemyTank.shots.size(); j++) {
                    //取出子弹
                    Shot shot = enemyTank.shots.get(j);
                    //绘制
                    if (shot.isLive) {
                        g.draw3DRect(shot.x, shot.y, 2, 2, false);
                    } else {
                        //从Vector移除
                        enemyTank.shots.remove(shot);
                    }
                }
            }
        }
    }
    //编写方法画出坦克

    /**
     * @param x      坦克左上角x坐标
     * @param y      坐上角y坐标
     * @param g      画笔
     * @param direct 坦克方向
     * @param type   坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x, y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
    //编写方法，判断敌人坦克是否击中我方坦克
    public void hitHero() {
        //遍历所有敌人的坦克，然后遍历敌人坦克的所有子弹来判断是否击中我方坦克
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出敌人坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //遍历enemyTank 对象的所有子弹
            for (int j = 0; j < enemyTank.shots.size(); j++) {
                //取出子弹
                Shot shot = enemyTank.shots.get(j);
                //判断shot是否击中我方坦克
                if (hero.isLive && shot.isLive) {
                    hitTank(shot, hero);
                }
            }
        }
    }

    //如果我们的坦克可以发射多个子弹，那么在判断我方子弹是否击中坦克的时候，就需要把我们的子弹集合中，所有的子弹，都取出和敌人的所有坦克进行判断
    public void hitEnemyTank() {

        for (int j = 0; j < hero.shots.size(); j++) {
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活
                Shot shot = hero.shots.get(j);
                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(shot, enemyTank);
                }
            }

        }
    }
    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public  void hitTank(Shot s, Tank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            if (hero.getY() > 0) {
                hero.moveUp();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            if (hero.getX() + 60 < 1000) {
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            if (hero.getY() + 60 < 750){
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            if (hero.getX() > 0) {
                hero.moveLeft();
            }
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
//            //判断hero子弹是否存在或者销毁,这是发射一颗子弹的情况
//            if (hero.shot == null || !hero.shot.isLive) {
//                hero.shotEnemyTank();
//            }
            //发射多颗子弹的情况
            hero.shotEnemyTank();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            hitEnemyTank();
            //继续判断敌人坦克是否击中我
            hitHero();
            this.repaint();
        }
    }
}

```



```java
public class TankGame03 extends JFrame {
    //定义Panel,因为将来的panel是要放在jrame上面去的
    Mypanel mp = null;
    public static void main(String[] args) {
        TankGame03 tankGame01 = new TankGame03();
    }
    public TankGame03() {
        mp = new Mypanel();
        //将mp放入到Thread 并启动
        Thread thread = new Thread(mp);
        thread.start();
        this.add(mp);//把面板，游戏的绘图区域加进去
        this.setSize(1300,950);
        this.addKeyListener(mp);//让JFrame监听键盘
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
        //在JFrame中增加响应关闭窗口的处理
        this.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                Recorder.keepRecord();
                System.out.println("监听到关闭窗口");
                System.exit(0);
            }
        });
    }
}
```

# 记录敌人坦克信息

```java
/**
 * 用来记录相关信息，与文件交互
 */
public class Recorder {
    //定义变量，记录我方击毁敌人坦克数
    private static int allEnemyTank = 0;
    //定义IO对象,准备写到文件中
    private static FileWriter fw = null;
    private static BufferedWriter bw = null;
    private static String recordFile = "src\\record.txt";
    //增加一个方法，当游戏退出时，将allnum保存到recordFile
    //对KeepRecord方法进行升级，保存敌人坦克的坐标和方向
    private static Vector<EnemyTank> enemyTanks = null;

    public static void setEnemyTanks(Vector<EnemyTank> enemyTanks) {
        Recorder.enemyTanks = enemyTanks;
    }

    public static void keepRecord() {
        try {
            bw = new BufferedWriter(new FileWriter(recordFile));
            bw.write(allEnemyTank + "\r\n");
            //遍历敌人坦克的vector然后根据情况保存
            //oop定义一个属性，然后通过setXXX得到敌人坦克的vector
            for (int i = 0; i < enemyTanks.size();i++) {
                //取出敌人坦克，
                EnemyTank enemyTank = enemyTanks.get(i);
                if (enemyTank.isLive) {
                    //保存该enemyTank信息
                    String record = enemyTank.getX() + " " + enemyTank.getY() + " " + enemyTank.getDirect();
                    //写入到文件
                    bw.write(record + "\r\n");
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public static int getAllEnemyTank() {
        return allEnemyTank;
    }

    public static void setAllEnemyTank(int allEnemyTank) {
        Recorder.allEnemyTank = allEnemyTank;
    }
    //当我方坦克击毁一个敌方坦克，就应当allEnemyTank++
    public static void addallEnemyTank() {
        Recorder.allEnemyTank++;
    }
}
```

```java
 public Mypanel() {
        //将MyPanel对象的enemyTanks设置给Recorde的敌人坦克集合
        Recorder.setEnemyTanks(enemyTanks);
        hero = new Hero(100, 500);//初始化自己的坦克
        hero.setSpeed(2);
```



# 继续上局比赛

把敌人的信息当做一个node对象恢复，恢复完了以后再用node节点里的属性去恢复信息。

<img src="https://cdn.jsdelivr.net/gh/hughmum/blogImage/img/202209260806762.png" alt="image-20220926080646447" style="zoom:33%;" />

Node.class

```java
package mu.tankgame03;

/**
 * 保存敌人和自己坦克的信息
 */
public class Node {
    private int x;
    private int y;
    private int direct;

    public Node(int x, int y, int direct) {
        this.x = x;
        this.y = y;
        this.direct = direct;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getDirect() {
        return direct;
    }

    public void setDirect(int direct) {
        this.direct = direct;
    }
}
```

主方法里

```java
public class TankGame03 extends JFrame {
    //定义Panel,因为将来的panel是要放在jrame上面去的
    Mypanel mp = null;
    static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        TankGame03 tankGame01 = new TankGame03();
    }
    public TankGame03() {
        System.out.println("请输入选择，1 新游戏， 2 继续上局");
        String key = scanner.next();
        mp = new Mypanel(key);
        //将mp放入到Thread 并启动
        Thread thread = new Thread(mp);
        thread.start();
        this.add(mp);//把面板，游戏的绘图区域加进去
        this.setSize(1300,950);
        this.addKeyListener(mp);//让JFrame监听键盘
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
        //在JFrame中增加响应关闭窗口的处理
        this.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                Recorder.keepRecord();
                System.out.println("监听到关闭窗口");
                System.exit(0);
            }
        });
    }
}
```

MyPanel.class

```JAVA
package mu.tankgame03;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.IOException;
import java.util.Vector;

/**
 * 坦克大战的绘图区域
 */
//为了监听 键盘事件， 实现KEyListener
//为了让Panel不停的重绘子弹，需要将MyPanel实现Runable接口，当作一个线程使用，不然的话，按下去paint这个方法只会调用一次，
public class Mypanel extends JPanel implements KeyListener, Runnable {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    //定义一个存放Node对象的Vector用于恢复敌人坦克的坐标和方向
    Vector<Node> nodes = null;
    int enemyTankSize = 7;
    //定义一个vector用于存放炸弹
    //说明当子弹击中坦克时，就加入一个Bomb对象，到bombs
    Vector<Bomb> bombs = new Vector<>();
    //定义三张炸弹图片，用于显示爆炸效果
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;

    public Mypanel(String key) {
        //将MyPanel对象的enemyTanks设置给Recorde的敌人坦克集合
        Recorder.setEnemyTanks(enemyTanks);
        hero = new Hero(100, 500);//初始化自己的坦克
        hero.setSpeed(2);
        switch (key) {
            case "1":
                //初始化敌人坦克
                for (int i = 0; i < enemyTankSize; i++) {
                    EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
                    enemyTank.setEnemyTanks(enemyTanks);
                    enemyTank.setDirect(2);
                    //启动敌人坦克线程
                    new Thread(enemyTank).start();
                    //给该敌人坦克加入一颗子弹
                    Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
                    //加入到enemyTank的vector
                    enemyTank.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemyTanks.add(enemyTank);
                }
                break;
            case "2"://继续上一局游戏
                try {
                    nodes = Recorder.getNodesAndAllEnemyTanks();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                //初始化敌人坦克
                for (int i = 0; i < nodes.size(); i++) {
                    Node node = nodes.get(i);
                    EnemyTank enemyTank = new EnemyTank(node.getX(), node.getY());
                    enemyTank.setEnemyTanks(enemyTanks);
                    enemyTank.setDirect(node.getDirect());
                    //启动敌人坦克线程
                    new Thread(enemyTank).start();
                    //给该敌人坦克加入一颗子弹
                    Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
                    //加入到enemyTank的vector
                    enemyTank.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemyTanks.add(enemyTank);
                }
                break;
            default:
                System.out.println("您输入有误");
        }
        //初始化图片对象
        image1 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image2 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
        image3 = Toolkit.getDefaultToolkit().getImage("D:\\code\\java\\learn\\hsp\\Tank\\src\\mu\\tankgame03\\img\\bomb_1.gif");
    }

    //编写方法，显示我方击毁敌方坦克信息
    public void showInfo(Graphics g)  {
        //画出玩家总成绩
        g.setColor(Color.BLACK);
        Font font = new Font("宋体", Font.BOLD, 24);
        g.setFont(font);

        g.drawString("您累积击毁敌方坦克", 1020,30);
        drawTank(1020, 60, g, 0, 1);//画出一个敌方坦克
        g.setColor(Color.BLACK);
        g.drawString(Recorder.getAllEnemyTank() + "", 1080, 100);
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
        showInfo(g);
        //画出坦克-封装方法方法
        if(hero != null && hero.isLive) {
            drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);
        }

//        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
//        if (hero.shot != null && hero.shot.isLive == true) {
//            System.out.println("子弹被绘制");
//            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
//        }

        //将hero的子弹集合，遍历取出绘制
        for (int i = 0; i < hero.shots.size(); i++) {
            Shot shot = hero.shots.get(i);
            if (shot != null && shot.isLive == true) {
                g.draw3DRect(shot.x, shot.y, 2, 2, false);
            } else {//如果该shot对象失效，就去除remove
                hero.shots.remove(shot);
            }
        }

        //如果bombs集合中有对象，就画出炸弹
        for (int i = 0; i < bombs.size(); i++) {
            //取出炸弹
            Bomb bomb = bombs.get(i);
            //根据当前这个bomb对象的life去画出对应的图片
            if (bomb.life > 6) {
                g.drawImage(image1, bomb.x, bomb.y,60,60,this );
            } else if (bomb.life > 3) {
                g.drawImage(image2, bomb.x, bomb.y,60,60,this );
            } else {
                g.drawImage(image3, bomb.x, bomb.y,60,60,this );
            }
            //让这个炸弹的生命值减少
            bomb.lifeDown();
            //如果bomb life为0， 就从bombs 的集合中删除这个bomb
            if (bomb.life == 0) {
                bombs.remove(bomb);
            }
        }
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //判断当前坦克是否存活
            if (enemyTank.isLive) {//只有敌人坦克活着才画
                drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 1);
                //画出所有子弹
                for (int j = 0; j < enemyTank.shots.size(); j++) {
                    //取出子弹
                    Shot shot = enemyTank.shots.get(j);
                    //绘制
                    if (shot.isLive) {
                        g.draw3DRect(shot.x, shot.y, 2, 2, false);
                    } else {
                        //从Vector移除
                        enemyTank.shots.remove(shot);
                    }
                }
            }
        }
    }
    //编写方法画出坦克

    /**
     * @param x      坦克左上角x坐标
     * @param y      坐上角y坐标
     * @param g      画笔
     * @param direct 坦克方向
     * @param type   坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x, y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
    //编写方法，判断敌人坦克是否击中我方坦克
    public void hitHero() {
        //遍历所有敌人的坦克，然后遍历敌人坦克的所有子弹来判断是否击中我方坦克
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出敌人坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //遍历enemyTank 对象的所有子弹
            for (int j = 0; j < enemyTank.shots.size(); j++) {
                //取出子弹
                Shot shot = enemyTank.shots.get(j);
                //判断shot是否击中我方坦克
                if (hero.isLive && shot.isLive) {
                    hitTank(shot, hero);
                }
            }
        }
    }

    //如果我们的坦克可以发射多个子弹，那么在判断我方子弹是否击中坦克的时候，就需要把我们的子弹集合中，所有的子弹，都取出和敌人的所有坦克进行判断
    public void hitEnemyTank() {

        for (int j = 0; j < hero.shots.size(); j++) {
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活
                Shot shot = hero.shots.get(j);
                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(shot, enemyTank);
                }
            }

        }
    }
    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public  void hitTank(Shot s, Tank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            if (hero.getY() > 0) {
                hero.moveUp();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            if (hero.getX() + 60 < 1000) {
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            if (hero.getY() + 60 < 750){
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            if (hero.getX() > 0) {
                hero.moveLeft();
            }
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
//            //判断hero子弹是否存在或者销毁,这是发射一颗子弹的情况
//            if (hero.shot == null || !hero.shot.isLive) {
//                hero.shotEnemyTank();
//            }
            //发射多颗子弹的情况
            hero.shotEnemyTank();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            hitEnemyTank();
            //继续判断敌人坦克是否击中我
            hitHero();
            this.repaint();
        }
    }
}
```

# 播放音乐



播放类 AePlayWave.class

```java
package mu.tankgame03;

import javax.sound.sampled.*;
import java.io.File;
import java.io.IOException;


public class AePlayWave extends Thread {
    private String filename;

    public AePlayWave(String wavfile) { //构造器 , 指定文件
        filename = wavfile;

    }

    public void run() {

        File soundFile = new File(filename);

        AudioInputStream audioInputStream = null;
        try {
            audioInputStream = AudioSystem.getAudioInputStream(soundFile);
        } catch (Exception e1) {
            e1.printStackTrace();
            return;
        }

        AudioFormat format = audioInputStream.getFormat();
        SourceDataLine auline = null;
        DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);

        try {
            auline = (SourceDataLine) AudioSystem.getLine(info);
            auline.open(format);
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        auline.start();
        int nBytesRead = 0;
        //这是缓冲
        byte[] abData = new byte[512];

        try {
            while (nBytesRead != -1) {
                nBytesRead = audioInputStream.read(abData, 0, abData.length);
                if (nBytesRead >= 0)
                    auline.write(abData, 0, nBytesRead);
            }
        } catch (IOException e) {
            e.printStackTrace();
            return;
        } finally {
            auline.drain();
            auline.close();
        }

    }
}
```

```java
package mu.tankgame03;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.File;
import java.io.IOException;
import java.util.Vector;

/**
 * 坦克大战的绘图区域
 */
//为了监听 键盘事件， 实现KEyListener
//为了让Panel不停的重绘子弹，需要将MyPanel实现Runable接口，当作一个线程使用，不然的话，按下去paint这个方法只会调用一次，
public class Mypanel extends JPanel implements KeyListener, Runnable {
    //定义我的坦克
    Hero hero = null;
    //定义敌人坦克,保证线程安全，放在vector集合中
    Vector<EnemyTank> enemyTanks = new Vector<>();
    //定义一个存放Node对象的Vector用于恢复敌人坦克的坐标和方向
    Vector<Node> nodes = null;
    int enemyTankSize = 7;
    //定义一个vector用于存放炸弹
    //说明当子弹击中坦克时，就加入一个Bomb对象，到bombs
    Vector<Bomb> bombs = new Vector<>();
    //定义三张炸弹图片，用于显示爆炸效果
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;


    public Mypanel(String key) {
        //先判断文件是否存在，如果存在就正常执行，否则，先创建再继续执行，
        File file  = new File(Recorder.getRecordFile());
        if (file.exists()) {
            try {
                nodes = Recorder.getNodesAndAllEnemyTanks();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("文件不存在，只能重新开始游戏");
            key = "1";
        }

        //将MyPanel对象的enemyTanks设置给Recorde的敌人坦克集合
        Recorder.setEnemyTanks(enemyTanks);
        hero = new Hero(100, 500);//初始化自己的坦克
        hero.setSpeed(2);
        switch (key) {
            case "1":
                //初始化敌人坦克
                for (int i = 0; i < enemyTankSize; i++) {
                    EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 20);
                    enemyTank.setEnemyTanks(enemyTanks);
                    enemyTank.setDirect(2);
                    //启动敌人坦克线程
                    new Thread(enemyTank).start();
                    //给该敌人坦克加入一颗子弹
                    Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
                    //加入到enemyTank的vector
                    enemyTank.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemyTanks.add(enemyTank);
                }
                break;
            case "2"://继续上一局游戏
                //初始化敌人坦克
                for (int i = 0; i < nodes.size(); i++) {
                    Node node = nodes.get(i);
                    EnemyTank enemyTank = new EnemyTank(node.getX(), node.getY());
                    enemyTank.setEnemyTanks(enemyTanks);
                    enemyTank.setDirect(node.getDirect());
                    //启动敌人坦克线程
                    new Thread(enemyTank).start();
                    //给该敌人坦克加入一颗子弹
                    Shot shot = new Shot(enemyTank.getX() + 20, enemyTank.getY() + 60, enemyTank.getDirect());
                    //加入到enemyTank的vector
                    enemyTank.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemyTanks.add(enemyTank);
                }
                break;
            default:
                System.out.println("您输入有误");
        }
        //初始化图片对象
        image1 = Toolkit.getDefaultToolkit().getImage("src\\mu\\tankgame03\\img\\bomb_1.gif");
        image2 = Toolkit.getDefaultToolkit().getImage("src\\mu\\tankgame03\\img\\bomb_1.gif");
        image3 = Toolkit.getDefaultToolkit().getImage("src\\mu\\tankgame03\\img\\bomb_1.gif");
        //播放指定的音乐。
        new AePlayWave("src\\111.wav").start();
    }

    //编写方法，显示我方击毁敌方坦克信息
    public void showInfo(Graphics g)  {
        //画出玩家总成绩
        g.setColor(Color.BLACK);
        Font font = new Font("宋体", Font.BOLD, 24);
        g.setFont(font);

        g.drawString("您累积击毁敌方坦克", 1020,30);
        drawTank(1020, 60, g, 0, 1);//画出一个敌方坦克
        g.setColor(Color.BLACK);
        g.drawString(Recorder.getAllEnemyTank() + "", 1080, 100);
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
        showInfo(g);
        //画出坦克-封装方法方法
        if(hero != null && hero.isLive) {
            drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 0);
        }

//        //画出hero射击的子弹 判断子弹是否为空，或者是否存活先
//        if (hero.shot != null && hero.shot.isLive == true) {
//            System.out.println("子弹被绘制");
//            g.draw3DRect(hero.shot.x, hero.shot.y, 2, 2, false);
//        }

        //将hero的子弹集合，遍历取出绘制
        for (int i = 0; i < hero.shots.size(); i++) {
            Shot shot = hero.shots.get(i);
            if (shot != null && shot.isLive == true) {
                g.draw3DRect(shot.x, shot.y, 2, 2, false);
            } else {//如果该shot对象失效，就去除remove
                hero.shots.remove(shot);
            }
        }

        //如果bombs集合中有对象，就画出炸弹
        for (int i = 0; i < bombs.size(); i++) {
            //取出炸弹
            Bomb bomb = bombs.get(i);
            //根据当前这个bomb对象的life去画出对应的图片
            if (bomb.life > 6) {
                g.drawImage(image1, bomb.x, bomb.y,60,60,this );
            } else if (bomb.life > 3) {
                g.drawImage(image2, bomb.x, bomb.y,60,60,this );
            } else {
                g.drawImage(image3, bomb.x, bomb.y,60,60,this );
            }
            //让这个炸弹的生命值减少
            bomb.lifeDown();
            //如果bomb life为0， 就从bombs 的集合中删除这个bomb
            if (bomb.life == 0) {
                bombs.remove(bomb);
            }
        }
        //画出敌人坦克,遍历vector
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //判断当前坦克是否存活
            if (enemyTank.isLive) {//只有敌人坦克活着才画
                drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 1);
                //画出所有子弹
                for (int j = 0; j < enemyTank.shots.size(); j++) {
                    //取出子弹
                    Shot shot = enemyTank.shots.get(j);
                    //绘制
                    if (shot.isLive) {
                        g.draw3DRect(shot.x, shot.y, 2, 2, false);
                    } else {
                        //从Vector移除
                        enemyTank.shots.remove(shot);
                    }
                }
            }
        }
    }
    //编写方法画出坦克

    /**
     * @param x      坦克左上角x坐标
     * @param y      坐上角y坐标
     * @param g      画笔
     * @param direct 坦克方向
     * @param type   坦克类型
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {

        //根据不同类型坦克，设置不同颜色
        switch (type) {
            case 0://我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌人的坦克
                g.setColor((Color.yellow));
                break;
        }

        //根据坦克方向，绘制坦克
        switch (direct) {
            case 0://表示向上
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y);//画出炮筒
                break;
            case 1://表示向右
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20);//画出炮筒
                break;
            case 2://表示向下
                g.fill3DRect(x, y, 10, 60, false);//画出坦克左边的轮子
                g.fill3DRect(x + 30, y, 10, 60, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 10, y + 20, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60);//画出炮筒
                break;
            case 3://表示向左
                g.fill3DRect(x, y, 60, 10, false);//画出坦克左边的轮子
                g.fill3DRect(x, y + 30, 60, 10, false);//画出坦克右边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);//画出中间矩形，坦克盖子
                g.fillOval(x + 20, y + 10, 20, 20);//画出中间圆形，坦克盖子
                g.drawLine(x + 30, y + 20, x, y + 20);//画出炮筒
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }
    //编写方法，判断敌人坦克是否击中我方坦克
    public void hitHero() {
        //遍历所有敌人的坦克，然后遍历敌人坦克的所有子弹来判断是否击中我方坦克
        for (int i = 0; i < enemyTanks.size(); i++) {
            //取出敌人坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            //遍历enemyTank 对象的所有子弹
            for (int j = 0; j < enemyTank.shots.size(); j++) {
                //取出子弹
                Shot shot = enemyTank.shots.get(j);
                //判断shot是否击中我方坦克
                if (hero.isLive && shot.isLive) {
                    hitTank(shot, hero);
                }
            }
        }
    }

    //如果我们的坦克可以发射多个子弹，那么在判断我方子弹是否击中坦克的时候，就需要把我们的子弹集合中，所有的子弹，都取出和敌人的所有坦克进行判断
    public void hitEnemyTank() {

        for (int j = 0; j < hero.shots.size(); j++) {
            if (hero.shot != null && hero.shot.isLive) {//如果我的子弹还存活
                Shot shot = hero.shots.get(j);
                //遍历敌人所有的坦克
                for (int i = 0; i < enemyTanks.size(); i++) {
                    EnemyTank enemyTank = enemyTanks.get(i);
                    hitTank(shot, enemyTank);
                }
            }

        }
    }
    //编写方法，判断我方的子弹是否击中坦克
    //什么时候判断我方的子弹是否击中坦克？放在run方法里判断
    public  void hitTank(Shot s, Tank enemyTank) {
        //判断s击中坦克
        switch (enemyTank.getDirect()) {
            case 0://上
            case 2://下 上下都长一个形状 一起处理
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 40
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 60) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
                break;
            case 1:
            case 3:
                if (s.x > enemyTank.getX() && s.x < enemyTank.getX() + 60
                        && s.y > enemyTank.getY() && s.y < enemyTank.getY() + 40) {
                    s.isLive = false;
                    enemyTank.isLive = false;
                    //当我方子弹击中地方坦克后，将enemyTank从vectort中拿掉
                    enemyTanks.remove(enemyTank);
                    //当我方击毁一个坦克数据，就对记录++
                    if (enemyTank instanceof EnemyTank) {
                        Recorder.addallEnemyTank();
                    }
                    //击中了坦克 创建一个Bomb对象，加入到bombs集合
                    Bomb bomb = new Bomb(enemyTank.getX(), enemyTank.getY());
                    bombs.add(bomb);
                }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            hero.setDirect(0);//方向改变
            //修改坦克坐标
            if (hero.getY() > 0) {
                hero.moveUp();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            hero.setDirect(1);//方向改变
            if (hero.getX() + 60 < 1000) {
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);//方向改变
            if (hero.getY() + 60 < 750){
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);//方向改变
            if (hero.getX() > 0) {
                hero.moveLeft();
            }
        }
        //如果用户按下j，发射
        if (e.getKeyCode() == KeyEvent.VK_J) {
            System.out.println("用户按下了j，开始射击");
//            //判断hero子弹是否存在或者销毁,这是发射一颗子弹的情况
//            if (hero.shot == null || !hero.shot.isLive) {
//                hero.shotEnemyTank();
//            }
            //发射多颗子弹的情况
            hero.shotEnemyTank();
        }
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void run() {//每隔100ms，重绘区域,刷新绘图区域
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //在重绘后就判断是否击中
            //相当于就是每隔100ms就判断是否击中了敌人的坦克
            hitEnemyTank();
            //继续判断敌人坦克是否击中我
            hitHero();
            this.repaint();
        }
    }
}
```

